/**
 * Telegram Mini App - Main Application
 * 
 * Теперь использует модульную структуру:
 * - modules/state.js - состояние и DOM элементы
 * - modules/utils.js - утилиты
 * - modules/catalog.js - каталог, категории, продукты, фильтры
 * - modules/cart.js - корзина
 * - modules/favorites.js - избранное
 * - modules/product.js - страница товара
 * - modules/navigation.js - навигация и поиск
 * - modules/shop.js - страница магазина
 * - modules/checkout.js - оформление заказа (частично, основная логика пока здесь)
 * - modules/myshop.js - мой магазин (частично, основная логика пока здесь)
 * 
 * Большие модули (checkout, myshop) постепенно переносятся из app.js.
 * См. MODULES_README.md для подробностей.
 */

// Используем state, elements и функции из модулей
// ВАЖНО: НЕ объявляем const/let state/elements, чтобы избежать конфликта с модулем state.js
// Вместо этого используем прямые обращения к window.App.state и window.App.elements

// Функции для получения актуальных ссылок (всегда возвращают текущие значения из window.App)
// Эти функции используются для доступа к state и elements из модулей
function getAppState() {
    return window.App?.state || {};
}

function getAppElements() {
    return window.App?.elements || {};
}

function getAppTg() {
    return window.App?.tg || window.Telegram?.WebApp;
}

// Создаем глобальные переменные через присваивание (не через const/let), чтобы избежать конфликтов
// Используем window для доступа, а затем создаем локальные ссылки
window._appStateRef = getAppState;
window._appElementsRef = getAppElements;
window._appTgRef = getAppTg;

// Для обратной совместимости создаем объекты-обертки, которые можно использовать как переменные
// но они не конфликтуют с const/let, так как это просто объекты
const appState = {
    get user() { return getAppState().user; },
    set user(v) { const s = getAppState(); if (s) s.user = v; },
    get categories() { return getAppState().categories; },
    set categories(v) { const s = getAppState(); if (s) s.categories = v; },
    get products() { return getAppState().products; },
    set products(v) { const s = getAppState(); if (s) s.products = v; },
    get cart() { return getAppState().cart; },
    set cart(v) { const s = getAppState(); if (s) s.cart = v; },
    get favorites() { return getAppState().favorites; },
    set favorites(v) { const s = getAppState(); if (s) s.favorites = v; },
    get currentCategory() { return getAppState().currentCategory; },
    set currentCategory(v) { const s = getAppState(); if (s) s.currentCategory = v; },
    get currentProduct() { return getAppState().currentProduct; },
    set currentProduct(v) { const s = getAppState(); if (s) s.currentProduct = v; },
    get loading() { return getAppState().loading; },
    set loading(v) { const s = getAppState(); if (s) s.loading = v; },
    get myShop() { return getAppState().myShop; },
    set myShop(v) { const s = getAppState(); if (s) s.myShop = v; },
    get mySubscription() { return getAppState().mySubscription; },
    set mySubscription(v) { const s = getAppState(); if (s) s.mySubscription = v; },
    get myProducts() { return getAppState().myProducts; },
    set myProducts(v) { const s = getAppState(); if (s) s.myProducts = v; },
    get subscriptionPlans() { return getAppState().subscriptionPlans; },
    set subscriptionPlans(v) { const s = getAppState(); if (s) s.subscriptionPlans = v; },
    get filters() { return getAppState().filters; },
    set filters(v) { const s = getAppState(); if (s) s.filters = v; },
    get checkout() { return getAppState().checkout; },
    set checkout(v) { const s = getAppState(); if (s) s.checkout = v; },
    get productForm() { return getAppState().productForm; },
    set productForm(v) { const s = getAppState(); if (s) s.productForm = v; },
    get shopOrders() { return getAppState().shopOrders; },
    set shopOrders(v) { const s = getAppState(); if (s) s.shopOrders = v; },
    get userOrders() { return getAppState().userOrders; },
    set userOrders(v) { const s = getAppState(); if (s) s.userOrders = v; },
    get statisticsCharts() { return getAppState().statisticsCharts; },
    set statisticsCharts(v) { const s = getAppState(); if (s) s.statisticsCharts = v; },
    get showAllSubscriptionHistory() { return getAppState().showAllSubscriptionHistory; },
    set showAllSubscriptionHistory(v) { const s = getAppState(); if (s) s.showAllSubscriptionHistory = v; },
    get deliveryMap() { return getAppState().deliveryMap; },
    set deliveryMap(v) { const s = getAppState(); if (s) s.deliveryMap = v; },
    get deliveryMapPlacemark() { return getAppState().deliveryMapPlacemark; },
    set deliveryMapPlacemark(v) { const s = getAppState(); if (s) s.deliveryMapPlacemark = v; },
    // Добавляем методы для полной совместимости
    reduce: function(fn, init) { return (getAppState().cart || []).reduce(fn, init); }
};

// Просто используем window.App.elements напрямую через функцию
function appElements() {
    return getAppElements();
}

// Функция для получения tg
function appTg() {
    return getAppTg();
}

// Создаем псевдонимы для обратной совместимости (но не как const/let переменные)
// Используем eval для создания переменных в глобальной области видимости (только для совместимости)
// Но лучше не использовать eval, а использовать прямое обращение через функции

// Создаем объекты-обертки, которые делегируют все обращения к window.App
// Это позволяет использовать state.property вместо getState().property
const stateWrapper = {
    get user() { return getState().user; },
    set user(v) { if (getState()) getState().user = v; },
    get categories() { return getState().categories; },
    set categories(v) { if (getState()) getState().categories = v; },
    get products() { return getState().products; },
    set products(v) { if (getState()) getState().products = v; },
    get cart() { return getState().cart; },
    set cart(v) { if (getState()) getState().cart = v; },
    get favorites() { return getState().favorites; },
    set favorites(v) { if (getState()) getState().favorites = v; },
    get currentCategory() { return getState().currentCategory; },
    set currentCategory(v) { if (getState()) getState().currentCategory = v; },
    get currentProduct() { return getState().currentProduct; },
    set currentProduct(v) { if (getState()) getState().currentProduct = v; },
    get loading() { return getState().loading; },
    set loading(v) { if (getState()) getState().loading = v; },
    get myShop() { return getState().myShop; },
    set myShop(v) { if (getState()) getState().myShop = v; },
    get mySubscription() { return getState().mySubscription; },
    set mySubscription(v) { if (getState()) getState().mySubscription = v; },
    get myProducts() { return getState().myProducts; },
    set myProducts(v) { if (getState()) getState().myProducts = v; },
    get subscriptionPlans() { return getState().subscriptionPlans; },
    set subscriptionPlans(v) { if (getState()) getState().subscriptionPlans = v; },
    get filters() { return getState().filters; },
    set filters(v) { if (getState()) getState().filters = v; },
    get checkout() { return getState().checkout; },
    set checkout(v) { if (getState()) getState().checkout = v; },
    get productForm() { return getState().productForm; },
    set productForm(v) { if (getState()) getState().productForm = v; },
    get shopOrders() { return getState().shopOrders; },
    set shopOrders(v) { if (getState()) getState().shopOrders = v; },
    get userOrders() { return getState().userOrders; },
    set userOrders(v) { if (getState()) getState().userOrders = v; },
    get statisticsCharts() { return getState().statisticsCharts; },
    set statisticsCharts(v) { if (getState()) getState().statisticsCharts = v; },
    get showAllSubscriptionHistory() { return getState().showAllSubscriptionHistory; },
    set showAllSubscriptionHistory(v) { if (getState()) getState().showAllSubscriptionHistory = v; },
    get deliveryMap() { return getState().deliveryMap; },
    set deliveryMap(v) { if (getState()) getState().deliveryMap = v; },
    get deliveryMapPlacemark() { return getState().deliveryMapPlacemark; },
    set deliveryMapPlacemark(v) { if (getState()) getState().deliveryMapPlacemark = v; }
};

const elementsWrapper = {
    get searchBtn() { return getAppElements().searchBtn; },
    get favoritesBtn() { return getAppElements().favoritesBtn; },
    get cartBtn() { return getAppElements().cartBtn; },
    get favoritesBadge() { return getAppElements().favoritesBadge; },
    get cartBadge() { return getAppElements().cartBadge; },
    get searchModal() { return getAppElements().searchModal; },
    get searchInput() { return getAppElements().searchInput; },
    get closeSearch() { return getAppElements().closeSearch; },
    get searchResults() { return getAppElements().searchResults; },
    get filterBtn() { return getAppElements().filterBtn; },
    get filterModal() { return getAppElements().filterModal; },
    get closeFilterModal() { return getAppElements().closeFilterModal; },
    get filterMinPrice() { return getAppElements().filterMinPrice; },
    get filterMaxPrice() { return getAppElements().filterMaxPrice; },
    get filterDiscounted() { return getAppElements().filterDiscounted; },
    get filterInStock() { return getAppElements().filterInStock; },
    get filterTrending() { return getAppElements().filterTrending; },
    get resetFilters() { return getAppElements().resetFilters; },
    get applyFilters() { return getAppElements().applyFilters; },
    get categoriesSlider() { return getAppElements().categoriesSlider; },
    get subcategoriesSection() { return getAppElements().subcategoriesSection; },
    get subcategoriesGrid() { return getAppElements().subcategoriesGrid; },
    get productsTitle() { return getAppElements().productsTitle; },
    get productsGrid() { return getAppElements().productsGrid; },
    get loadingIndicator() { return getAppElements().loadingIndicator; },
    get emptyState() { return getAppElements().emptyState; },
    get bannerSection() { return getAppElements().bannerSection; },
    get productPage() { return getAppElements().productPage; },
    get productBackBtn() { return getAppElements().productBackBtn; },
    get productPageTitle() { return getAppElements().productPageTitle; },
    get productGallery() { return getAppElements().productGallery; },
    get productName() { return getAppElements().productName; },
    get productShop() { return getAppElements().productShop; },
    get productPrice() { return getAppElements().productPrice; },
    get productOldPrice() { return getAppElements().productOldPrice; },
    get productDiscount() { return getAppElements().productDiscount; },
    get productDescription() { return getAppElements().productDescription; },
    get productFavoriteBtn() { return getAppElements().productFavoriteBtn; },
    get qtyMinus() { return getAppElements().qtyMinus; },
    get qtyPlus() { return getAppElements().qtyPlus; },
    get qtyValue() { return getAppElements().qtyValue; },
    get addToCartBtn() { return getAppElements().addToCartBtn; },
    get cartPage() { return getAppElements().cartPage; },
    get favoritesPage() { return getAppElements().favoritesPage; },
    get profilePage() { return getAppElements().profilePage; },
    get settingsPage() { return getAppElements().settingsPage; },
    get helpPage() { return getAppElements().helpPage; },
    get cartItems() { return getAppElements().cartItems; },
    get cartEmpty() { return getAppElements().cartEmpty; },
    get cartSummary() { return getAppElements().cartSummary; },
    get cartTotal() { return getAppElements().cartTotal; },
    get summaryCount() { return getAppElements().summaryCount; },
    get summarySubtotal() { return getAppElements().summarySubtotal; },
    get summaryDiscountRow() { return getAppElements().summaryDiscountRow; },
    get summaryDiscount() { return getAppElements().summaryDiscount; },
    get summaryTotal() { return getAppElements().summaryTotal; },
    get checkoutBtn() { return getAppElements().checkoutBtn; },
    get clearCartBtn() { return getAppElements().clearCartBtn; },
    get cartNavBadge() { return getAppElements().cartNavBadge; },
    get favoritesGrid() { return getAppElements().favoritesGrid; },
    get favoritesEmpty() { return getAppElements().favoritesEmpty; },
    get profileName() { return getAppElements().profileName; },
    get profileUsername() { return getAppElements().profileUsername; },
    get profilePhone() { return getAppElements().profilePhone; },
    get profileAvatar() { return getAppElements().profileAvatar; },
    get myShopPage() { return getAppElements().myShopPage; },
    get shopCreateSection() { return getAppElements().shopCreateSection; },
    get shopDashboard() { return getAppElements().shopDashboard; },
    get shopCreateForm() { return getAppElements().shopCreateForm; },
    get shopName() { return getAppElements().shopName; },
    get shopDescription() { return getAppElements().shopDescription; },
    get shopAddress() { return getAppElements().shopAddress; },
    get shopPhone() { return getAppElements().shopPhone; },
    get shopEmail() { return getAppElements().shopEmail; },
    get shopPhotoUpload() { return getAppElements().shopPhotoUpload; },
    get shopPhoto() { return getAppElements().shopPhoto; },
    get shopPhotoPreview() { return getAppElements().shopPhotoPreview; },
    get descCharCount() { return getAppElements().descCharCount; },
    get shopOrdersPage() { return getAppElements().shopOrdersPage; },
    get shopReviewsPage() { return getAppElements().shopReviewsPage; },
    get shopStatisticsPage() { return getAppElements().shopStatisticsPage; },
    get shopProductsPage() { return getAppElements().shopProductsPage; },
    get shopSubscriptionPage() { return getAppElements().shopSubscriptionPage; },
    get dashboardShopPhoto() { return getAppElements().dashboardShopPhoto; },
    get dashboardShopName() { return getAppElements().dashboardShopName; },
    get shopRating() { return getAppElements().shopRating; },
    get shopOrdersCount() { return getAppElements().shopOrdersCount; },
    get shopProductsCount() { return getAppElements().shopProductsCount; },
    get shopRevenue() { return getAppElements().shopRevenue; },
    get dashboardShopRating() { return getAppElements().dashboardShopRating; },
    get dashboardReviewsCount() { return getAppElements().dashboardReviewsCount; },
    get dashboardProductsCount() { return getAppElements().dashboardProductsCount; },
    get dashboardRedemptionRate() { return getAppElements().dashboardRedemptionRate; },
    get editShopBtn() { return getAppElements().editShopBtn; },
    get addProductBtn() { return getAppElements().addProductBtn; },
    get myProductsBtn() { return getAppElements().myProductsBtn; },
    get subscriptionCard() { return getAppElements().subscriptionCard; },
    get subscriptionStatus() { return getAppElements().subscriptionStatus; },
    get subscriptionInfo() { return getAppElements().subscriptionInfo; },
    get noSubscription() { return getAppElements().noSubscription; },
    get currentPlanName() { return getAppElements().currentPlanName; },
    get daysRemaining() { return getAppElements().daysRemaining; },
    get manageSubscriptionBtn() { return getAppElements().manageSubscriptionBtn; },
    get editShopModal() { return getAppElements().editShopModal; },
    get closeEditShopModal() { return getAppElements().closeEditShopModal; },
    get shopEditForm() { return getAppElements().shopEditForm; },
    get subscriptionModal() { return getAppElements().subscriptionModal; },
    get closeSubscriptionModal() { return getAppElements().closeSubscriptionModal; },
    get plansList() { return getAppElements().plansList; },
    get addProductModal() { return getAppElements().addProductModal; },
    get closeAddProductModal() { return getAppElements().closeAddProductModal; },
    get addProductForm() { return getAppElements().addProductForm; },
    get productCategoryInput() { return getAppElements().productCategoryInput; },
    get myProductsList() { return getAppElements().myProductsList; },
    get myProductsEmpty() { return getAppElements().myProductsEmpty; },
    get addProductFromListBtn() { return getAppElements().addProductFromListBtn; },
    get addFirstProductBtn() { return getAppElements().addFirstProductBtn; },
    get subscriptionManagementPage() { return getAppElements().subscriptionManagementPage; },
    get shopPage() { return getAppElements().shopPage; },
    get subscriptionStatusBadge() { return getAppElements().subscriptionStatusBadge; },
    get managementPlanName() { return getAppElements().managementPlanName; },
    get subscriptionStartDate() { return getAppElements().subscriptionStartDate; },
    get subscriptionEndDate() { return getAppElements().subscriptionEndDate; },
    get subscriptionDaysRemaining() { return getAppElements().subscriptionDaysRemaining; },
    get subscriptionProgressFill() { return getAppElements().subscriptionProgressFill; },
    get extendSubscriptionBtn() { return getAppElements().extendSubscriptionBtn; },
    get changePlanBtn() { return getAppElements().changePlanBtn; },
    get subscriptionLimitsCard() { return getAppElements().subscriptionLimitsCard; },
    get productsUsage() { return getAppElements().productsUsage; },
    get productsLimitFill() { return getAppElements().productsLimitFill; },
    get promotionsUsage() { return getAppElements().promotionsUsage; },
    get promotionsLimitFill() { return getAppElements().promotionsLimitFill; },
    get subscriptionHistoryList() { return getAppElements().subscriptionHistoryList; },
    get subscriptionHistoryEmpty() { return getAppElements().subscriptionHistoryEmpty; },
    get showAllHistoryBtn() { return getAppElements().showAllHistoryBtn; },
    get bottomNav() { return getAppElements().bottomNav; },
    get toastContainer() { return getAppElements().toastContainer; },
    get shopOrdersList() { return getAppElements().shopOrdersList; },
    get ordersFilterTabs() { return getAppElements().ordersFilterTabs; },
    get myOrdersBtn() { return getAppElements().myOrdersBtn; },
    get myOrdersPage() { return getAppElements().myOrdersPage; },
    get userOrdersList() { return getAppElements().userOrdersList; },
    get userOrdersEmpty() { return getAppElements().userOrdersEmpty; },
    get myShopBtn() { return getAppElements().myShopBtn; },
    get settingsBtn() { return getAppElements().settingsBtn; },
    get helpBtn() { return getAppElements().helpBtn; },
    get shopReviewsPage() { return getAppElements().shopReviewsPage; }
};

// Создаем глобальные переменные state и elements через window, чтобы избежать конфликта с const/let
// Это позволяет использовать state.property и elements.property в коде без конфликтов
// Удаляем существующие свойства, если они есть, перед переопределением
if (window.hasOwnProperty('appState')) {
    delete window.appState;
}
if (window.hasOwnProperty('appElements')) {
    delete window.appElements;
}

// Создаем глобальные ссылки для обратной совместимости
window.appState = stateWrapper;
window.appElements = elementsWrapper;
window.appStateRef = stateWrapper;
window.appElementsRef = elementsWrapper;

// Создаем глобальные переменные state и elements (не через const/let)
// Они будут использоваться в коде как state.property и elements.property
window.state = stateWrapper;
window.elements = elementsWrapper;
window.tg = getAppTg();

// Создаем локальные переменные elements и state через присваивание (не через const/let)
// Это позволяет использовать elements.property и state.property в коде напрямую
// Используем eval для создания переменных в глобальной области видимости скрипта
// Но безопаснее использовать window.elements и window.state
// Для совместимости создаем локальные ссылки через функцию
(function() {
    // Создаем локальные переменные в области видимости функции
    // которые будут доступны через замыкание
    var localElements = elementsWrapper;
    var localState = stateWrapper;
    var localTg = getAppTg();
    
    // Экспортируем в глобальную область через window
    window._localElements = localElements;
    window._localState = localState;
    window._localTg = localTg;
})();

// Создаем глобальные переменные через присваивание (не через const/let)
// Это позволяет использовать elements и state напрямую в коде
// Но только если они не объявлены через const/let в других скриптах
try {
    // Пытаемся создать переменные через присваивание
    // Если они уже объявлены через const/let, это вызовет ошибку
    if (typeof elements === 'undefined') {
        window.elements = elementsWrapper;
    }
    if (typeof state === 'undefined') {
        window.state = stateWrapper;
    }
    if (typeof tg === 'undefined') {
        window.tg = getAppTg();
    }
} catch (e) {
    console.warn('Не удалось создать локальные переменные elements/state:', e);
}

// Создаем локальные переменные elements и state через var
// Это позволяет использовать elements.property и state.property в коде напрямую
// var не вызывает конфликта с const в других модулях, так как они в разных областях видимости
// Инициализируем пустыми объектами, они будут обновлены в initElements()
var elements = window.elements = {};
var state = window.state = {};
var tg = window.tg = null;

const { formatPrice, formatDate: formatDateString, showToast, showLoading, updateCartBadge, updateFavoritesBadge, debounce, getMediaUrl, pluralize } = window.App?.utils || {};

// Инициализация элементов (если модуль загружен, иначе используем старую функцию)
function initElements() {
    console.log('[INIT] initElements() called');
    console.log('[INIT] window.App exists:', !!window.App);
    console.log('[INIT] window.App.initElements exists:', !!window.App?.initElements);
    
    if (window.App?.initElements) {
        console.log('[INIT] Calling window.App.initElements()...');
        window.App.initElements();
        
        // Обновляем ссылки на state и elements после инициализации
        // Используем реальные объекты из window.App, а не обертки
        const realState = window.App.state || {};
        const realElements = window.App.elements || {};
        
        console.log('[INIT] realElements keys:', Object.keys(realElements).length, 'elements:', Object.keys(realElements).slice(0, 5));
        console.log('[INIT] realState keys:', Object.keys(realState).length);
        
        // Обновляем window и локальные переменные
        // Прямо присваиваем ссылки на объекты
        window.state = realState;
        window.elements = realElements;
        window.tg = window.App.tg || window.Telegram?.WebApp;
        
        // Обновляем локальные переменные через прямое присваивание
        // Очищаем старые свойства и копируем новые
        Object.keys(elements).forEach(key => delete elements[key]);
        Object.keys(realElements).forEach(key => {
            elements[key] = realElements[key];
        });
        
        Object.keys(state).forEach(key => delete state[key]);
        Object.keys(realState).forEach(key => {
            state[key] = realState[key];
        });
        
        tg = window.tg;
        
        console.log('[INIT] Elements updated from module, count:', Object.keys(elements).length);
        console.log('[INIT] elements.searchBtn:', !!elements.searchBtn);
        console.log('[INIT] elements.productsGrid:', !!elements.productsGrid);
        console.log('[INIT] elements.categoriesSlider:', !!elements.categoriesSlider);
        return;
    }
    
    // Fallback для обратной совместимости
    console.log('[INIT] Using fallback initialization (window.App.initElements not available)');
    var fallbackElements = {
        // Header
        searchBtn: document.getElementById('searchBtn'),
        favoritesBtn: document.getElementById('favoritesBtn'),
        cartBtn: document.getElementById('cartBtn'),
    favoritesBadge: document.getElementById('favoritesBadge'),
    cartBadge: document.getElementById('cartBadge'),
    
    // Search
    searchModal: document.getElementById('searchModal'),
    searchInput: document.getElementById('searchInput'),
    closeSearch: document.getElementById('closeSearch'),
    searchResults: document.getElementById('searchResults'),
    
    // Filters
    filterBtn: document.getElementById('filterBtn'),
    filterModal: document.getElementById('filterModal'),
    closeFilterModal: document.getElementById('closeFilterModal'),
    filterMinPrice: document.getElementById('filterMinPrice'),
    filterMaxPrice: document.getElementById('filterMaxPrice'),
    filterDiscounted: document.getElementById('filterDiscounted'),
    filterInStock: document.getElementById('filterInStock'),
    filterTrending: document.getElementById('filterTrending'),
    resetFilters: document.getElementById('resetFilters'),
    applyFilters: document.getElementById('applyFilters'),
    
    // Categories
    categoriesSlider: document.getElementById('categoriesSlider'),
    subcategoriesSection: document.getElementById('subcategoriesSection'),
    subcategoriesGrid: document.getElementById('subcategoriesGrid'),
    
    // Products
    productsTitle: document.getElementById('productsTitle'),
    productsGrid: document.getElementById('productsGrid'),
    loadingIndicator: document.getElementById('loadingIndicator'),
    emptyState: document.getElementById('emptyState'),
    bannerSection: document.getElementById('bannerSection'),
    
    // Product Page
    productPage: document.getElementById('productPage'),
    productBackBtn: document.getElementById('productBackBtn'),
    productPageTitle: document.getElementById('productPageTitle'),
    productGallery: document.getElementById('productGallery'),
    productName: document.getElementById('productName'),
    productShop: document.getElementById('productShop'),
    productPrice: document.getElementById('productPrice'),
    productOldPrice: document.getElementById('productOldPrice'),
    productDiscount: document.getElementById('productDiscount'),
    productDescription: document.getElementById('productDescription'),
    productFavoriteBtn: document.getElementById('productFavoriteBtn'),
    qtyMinus: document.getElementById('qtyMinus'),
    qtyPlus: document.getElementById('qtyPlus'),
    qtyValue: document.getElementById('qtyValue'),
    addToCartBtn: document.getElementById('addToCartBtn'),
    
    // Pages
    productPage: document.getElementById('productPage'),
    cartPage: document.getElementById('cartPage'),
    favoritesPage: document.getElementById('favoritesPage'),
    profilePage: document.getElementById('profilePage'),
    settingsPage: document.getElementById('settingsPage'),
    helpPage: document.getElementById('helpPage'),
    
    // Cart
    cartItems: document.getElementById('cartItems'),
    cartEmpty: document.getElementById('cartEmpty'),
    cartSummary: document.getElementById('cartSummary'),
    clearCartBtn: document.getElementById('clearCartBtn'),
    summaryCount: document.getElementById('summaryCount'),
    summarySubtotal: document.getElementById('summarySubtotal'),
    summaryDiscountRow: document.getElementById('summaryDiscountRow'),
    summaryDiscount: document.getElementById('summaryDiscount'),
    summaryTotal: document.getElementById('summaryTotal'),
    checkoutBtn: document.getElementById('checkoutBtn'),
    cartNavBadge: document.getElementById('cartNavBadge'),
    
    // Favorites
    favoritesGrid: document.getElementById('favoritesGrid'),
    favoritesEmpty: document.getElementById('favoritesEmpty'),
    
    // Orders
    
    // Profile
    profileName: document.getElementById('profileName'),
    profileUsername: document.getElementById('profileUsername'),
    myOrdersBtn: document.getElementById('myOrdersBtn'),
    myShopBtn: document.getElementById('myShopBtn'),
    settingsBtn: document.getElementById('settingsBtn'),
    helpBtn: document.getElementById('helpBtn'),
    
    // My Orders
    myOrdersPage: document.getElementById('myOrdersPage'),
    userOrdersList: document.getElementById('userOrdersList'),
    userOrdersEmpty: document.getElementById('userOrdersEmpty'),
    
    // Settings
    notifyOrders: document.getElementById('notifyOrders'),
    notifyMessages: document.getElementById('notifyMessages'),
    notifyPromotions: document.getElementById('notifyPromotions'),
    autoPlayVideos: document.getElementById('autoPlayVideos'),
    showImagesOnly: document.getElementById('showImagesOnly'),
    appVersion: document.getElementById('appVersion'),
    clearCacheBtn: document.getElementById('clearCacheBtn'),
    saveSettingsBtn: document.getElementById('saveSettingsBtn'),
    
    // My Shop
    myShopPage: document.getElementById('myShopPage'),
    shopCreateSection: document.getElementById('shopCreateSection'),
    shopDashboard: document.getElementById('shopDashboard'),
    shopCreateForm: document.getElementById('shopCreateForm'),
    shopName: document.getElementById('shopName'),
    shopDescription: document.getElementById('shopDescription'),
    shopAddress: document.getElementById('shopAddress'),
    shopPhone: document.getElementById('shopPhone'),
    shopEmail: document.getElementById('shopEmail'),
    shopPhotoUpload: document.getElementById('shopPhotoUpload'),
    shopPhoto: document.getElementById('shopPhoto'),
    shopPhotoPreview: document.getElementById('shopPhotoPreview'),
    descCharCount: document.getElementById('descCharCount'),
    
    // Shop Dashboard
    dashboardShopPhoto: document.getElementById('dashboardShopPhoto'),
    dashboardShopName: document.getElementById('dashboardShopName'),
    dashboardShopRating: document.getElementById('dashboardShopRating'),
    dashboardReviewsCount: document.getElementById('dashboardReviewsCount'),
    dashboardProductsCount: document.getElementById('dashboardProductsCount'),
    dashboardOrdersCount: document.getElementById('dashboardOrdersCount'),
    dashboardRedemptionRate: document.getElementById('dashboardRedemptionRate'),
    editShopBtn: document.getElementById('editShopBtn'),
    addProductBtn: document.getElementById('addProductBtn'),
    myProductsBtn: document.getElementById('myProductsBtn'),
    
    // Subscription
    subscriptionCard: document.getElementById('subscriptionCard'),
    subscriptionStatus: document.getElementById('subscriptionStatus'),
    subscriptionInfo: document.getElementById('subscriptionInfo'),
    noSubscription: document.getElementById('noSubscription'),
    currentPlanName: document.getElementById('currentPlanName'),
    daysRemaining: document.getElementById('daysRemaining'),
    manageSubscriptionBtn: document.getElementById('manageSubscriptionBtn'),
    
    // Modals
    editShopModal: document.getElementById('editShopModal'),
    closeEditShopModal: document.getElementById('closeEditShopModal'),
    shopEditForm: document.getElementById('shopEditForm'),
    subscriptionModal: document.getElementById('subscriptionModal'),
    closeSubscriptionModal: document.getElementById('closeSubscriptionModal'),
    plansList: document.getElementById('plansList'),
    addProductModal: document.getElementById('addProductModal'),
    closeAddProductModal: document.getElementById('closeAddProductModal'),
    addProductForm: document.getElementById('addProductForm'),
    productCategoryInput: document.getElementById('productCategoryInput'),
    
    // My Products
    myProductsPage: document.getElementById('myProductsPage'),
    myProductsList: document.getElementById('myProductsList'),
    myProductsEmpty: document.getElementById('myProductsEmpty'),
    addProductFromListBtn: document.getElementById('addProductFromListBtn'),
    addFirstProductBtn: document.getElementById('addFirstProductBtn'),
    
    // Subscription Management
    subscriptionManagementPage: document.getElementById('subscriptionManagementPage'),
    shopPage: document.getElementById('shopPage'),
    subscriptionStatusBadge: document.getElementById('subscriptionStatusBadge'),
    managementPlanName: document.getElementById('managementPlanName'),
    subscriptionStartDate: document.getElementById('subscriptionStartDate'),
    subscriptionEndDate: document.getElementById('subscriptionEndDate'),
    subscriptionDaysRemaining: document.getElementById('subscriptionDaysRemaining'),
    subscriptionProgressFill: document.getElementById('subscriptionProgressFill'),
    extendSubscriptionBtn: document.getElementById('extendSubscriptionBtn'),
    changePlanBtn: document.getElementById('changePlanBtn'),
    subscriptionLimitsCard: document.getElementById('subscriptionLimitsCard'),
    productsUsage: document.getElementById('productsUsage'),
    productsLimitFill: document.getElementById('productsLimitFill'),
    promotionsUsage: document.getElementById('promotionsUsage'),
    promotionsLimitFill: document.getElementById('promotionsLimitFill'),
    subscriptionHistoryList: document.getElementById('subscriptionHistoryList'),
    subscriptionHistoryEmpty: document.getElementById('subscriptionHistoryEmpty'),
    showAllHistoryBtn: document.getElementById('showAllHistoryBtn'),
    
    // Navigation
    bottomNav: document.querySelector('.bottom-nav'),
    
    // Toast
    toastContainer: document.getElementById('toastContainer'),
    };
    
    // Обновляем window.elements и локальную переменную elements
    window.elements = fallbackElements;
    window.state = {};
    window.tg = window.Telegram?.WebApp;
    
    // Обновляем локальные переменные через прямое присваивание свойств
    // Важно: не создаем новую переменную, а обновляем существующую
    Object.keys(elements).forEach(key => delete elements[key]);
    Object.keys(fallbackElements).forEach(key => {
        elements[key] = fallbackElements[key];
    });
    
    console.log('[INIT] Elements initialized from fallback, count:', Object.keys(elements).length);
    console.log('[INIT] elements.searchBtn:', !!elements.searchBtn);
    console.log('[INIT] elements.productsGrid:', !!elements.productsGrid);
    console.log('[INIT] elements.categoriesSlider:', !!elements.categoriesSlider);
    
    // Проверяем, что основные элементы найдены
    const requiredElements = ['searchBtn', 'categoriesSlider', 'productsGrid', 'bottomNav'];
    const missing = requiredElements.filter(id => !elements[id]);
    if (missing.length > 0) {
        console.error('Missing required elements:', missing);
    }
}

// ==================== Initialization ====================

async function init() {
    console.log('[INIT] Starting initialization...');
    
    try {
        // Проверяем, что api загружен
        if (typeof api === 'undefined') {
            console.error('[INIT] API клиент не загружен! Проверьте, что api.js загружается первым.');
            alert('ОШИБКА: API клиент не загружен. Проверьте консоль (F12)');
            return;
        }
        
        // Инициализируем DOM элементы
        initElements();
        console.log('[INIT] Elements initialized');
        
        // Проверяем, что основные элементы найдены (делаем проверку мягче)
        if (!elements.categoriesSlider) {
            console.error('[INIT] categoriesSlider не найден!');
        }
        if (!elements.productsGrid) {
            console.error('[INIT] productsGrid не найден!');
        }
        if (!elements.bottomNav) {
            console.warn('[INIT] bottomNav не найден, но продолжаем');
        }
        
        // Критичные элементы для загрузки данных
        if (!elements.productsGrid) {
            console.error('[INIT] Не могу продолжить без productsGrid');
            alert('ОШИБКА: Не найден элемент productsGrid. Проверьте консоль (F12).');
            return;
        }
        
        // Инициализация Telegram WebApp
        if (tg && tg.initDataUnsafe?.user) {
            tg.ready();
            tg.expand();
            
            // Применяем тему Telegram
            applyTelegramTheme();
            
            // Получаем данные пользователя
            const user = tg.initDataUnsafe.user;
            api.setTelegramId(user.id);
            state.user = user;
            
            // Обновляем профиль
            if (elements.profileName) elements.profileName.textContent = user.first_name || 'Пользователь';
            if (elements.profileUsername) elements.profileUsername.textContent = user.username ? `@${user.username}` : '';
            
            // Регистрируем пользователя
            try {
                await api.createOrUpdateUser({
                    telegram_id: user.id,
                    username: user.username,
                    first_name: user.first_name,
                    last_name: user.last_name,
                    language_code: user.language_code,
                    is_premium: user.is_premium || false,
                });
            } catch (error) {
                console.error('Error registering user:', error);
            }
        } else {
            // DEV MODE: Тестовый пользователь для разработки без Telegram
            console.log('DEV MODE: Creating test user');
            const testUser = {
                id: 123456789,
                username: 'testuser',
                first_name: 'Тестовый',
                last_name: 'Пользователь',
                language_code: 'ru',
                is_premium: false,
            };
            
            api.setTelegramId(testUser.id);
            state.user = testUser;
            
            if (elements.profileName) elements.profileName.textContent = testUser.first_name;
            if (elements.profileUsername) elements.profileUsername.textContent = `@${testUser.username}`;
            
            // Регистрируем тестового пользователя
            try {
                await api.createOrUpdateUser({
                    telegram_id: testUser.id,
                    username: testUser.username,
                    first_name: testUser.first_name,
                    last_name: testUser.last_name,
                    language_code: testUser.language_code,
                    is_premium: testUser.is_premium,
                });
            } catch (error) {
                console.error('Error registering test user:', error);
            }
        }
        
        // Загружаем данные (для всех пользователей)
        console.log('[INIT] Loading categories and products...');
        console.log('[INIT] API baseUrl:', api.baseUrl);
        console.log('[INIT] Current location:', window.location.href);
        
        try {
            // Загружаем по очереди для лучшей диагностики
            await loadCategories();
            
            // Сначала загружаем избранное (если есть пользователь), чтобы карточки сразу рендерились с правильными сердечками
            if (state.user) {
                try {
                    if (window.App?.favorites?.loadFavorites) {
                        await window.App.favorites.loadFavorites();
                    }
                    console.log('[INIT] Favorites loaded, count:', state.favorites.length);
                } catch (error) {
                    console.error('Error loading favorites:', error);
                    state.favorites = [];
                }
            } else {
                state.favorites = [];
            }
            
            // Теперь загружаем товары - они будут рендериться с правильными сердечками
            await loadProducts();
            
            console.log('[INIT] ✅ Данные загружены успешно');
        } catch (error) {
            console.error('[INIT] ❌ Failed to load initial data:', error);
            console.error('[INIT] Error stack:', error.stack);
            
            // Показываем сообщение пользователю
            if (elements.productsGrid) {
                elements.productsGrid.innerHTML = `
                    <div style="padding: 40px 20px; text-align: center; max-width: 400px; margin: 0 auto;">
                        <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                        <h3 style="margin-bottom: 8px; color: #333;">Не удалось загрузить данные</h3>
                        <p style="color: #666; margin-bottom: 12px; font-size: 14px;">
                            Проверьте:
                        </p>
                        <ul style="text-align: left; color: #666; font-size: 14px; margin-bottom: 20px; padding-left: 20px;">
                            <li>Сервер запущен на <strong>http://127.0.0.1:8080</strong></li>
                            <li>Откройте консоль (F12) для деталей</li>
                        </ul>
                        <div style="margin-bottom: 16px; padding: 12px; background: #f5f5f5; border-radius: 8px; font-size: 12px; color: #666; text-align: left;">
                            <strong>Ошибка:</strong><br>
                            ${error.message || 'Неизвестная ошибка'}
                        </div>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">
                            Обновить страницу
                        </button>
                    </div>
                `;
            }
        }
        
        // Загружаем корзину отдельно (избранное уже загружено выше)
        if (state.user) {
            try {
                await loadCart();
            } catch (error) {
                console.error('Error loading cart:', error);
            }
        }
        
        // Скрываем кнопку "Мой магазин" по умолчанию (будет показана если магазин есть при переходе на профиль)
        if (elements.myShopBtn) {
            elements.myShopBtn.style.display = 'none';
        }
        
        // Инициализируем обработчики
        console.log('[INIT] Initializing event listeners...');
        initEventListeners();
        initSubscriptionManagementHandlers();
        initStatisticsDashboard();
        
        console.log('[INIT] Initialization complete!');
    } catch (error) {
        console.error('[INIT] Ошибка при инициализации:', error);
        console.error('Stack:', error.stack);
        alert('Ошибка инициализации: ' + error.message + '\nПроверьте консоль для деталей.');
    }
}

function applyTelegramTheme() {
    if (!tg?.themeParams) return;
    
    const theme = tg.themeParams;
    const root = document.documentElement;
    
    if (theme.bg_color) {
        root.style.setProperty('--bg-secondary', theme.bg_color);
    }
    if (theme.secondary_bg_color) {
        root.style.setProperty('--bg-primary', theme.secondary_bg_color);
        root.style.setProperty('--bg-tertiary', theme.secondary_bg_color);
    }
    if (theme.text_color) {
        root.style.setProperty('--text-primary', theme.text_color);
    }
    if (theme.hint_color) {
        root.style.setProperty('--text-secondary', theme.hint_color);
        root.style.setProperty('--text-muted', theme.hint_color);
    }
    if (theme.button_color) {
        root.style.setProperty('--primary', theme.button_color);
    }
}

// ==================== Data Loading ====================
// Функции loadCategories, loadProducts перенесены в modules/catalog.js
// Функция loadCart перенесена в modules/cart.js
// Функции loadFavorites, isProductFavorite, updateFavoriteButtons перенесены в modules/favorites.js

// ==================== Filters ====================
// Функции applyClientFilters, openFilterModal, closeFilterModal, applyFilters, resetFilters перенесены в modules/catalog.js

// ==================== Rendering ====================
// Функции getCategoryIconFileName, renderCategories, renderProducts, createProductCard, initProductCardSlider, renderSubcategories перенесены в modules/catalog.js
// Функция renderFavorites перенесена в modules/favorites.js

// ==================== Event Listeners ====================

function initEventListeners() {
    console.log('[EVENTS] Setting up event listeners...');
    
    // Поиск
    if (!elements.searchBtn || !elements.closeSearch || !elements.categoriesSlider) {
        console.error('[EVENTS] Critical elements not found. Some features may not work.');
        return;
    }
    
    // Поиск
    console.log('[EVENTS] Setting up search button...');
    elements.searchBtn.addEventListener('click', (e) => {
        console.log('[CLICK] Search button clicked');
        openSearch();
    });
    elements.closeSearch.addEventListener('click', closeSearch);
    elements.searchInput?.addEventListener('input', debounce(handleSearch, 300));
    
    // Категории
    elements.categoriesSlider.addEventListener('click', (e) => {
        const chip = e.target.closest('.category-chip');
        if (chip) {
            const category = chip.dataset.category;
            selectCategory(category);
        }
    });
    
    // Кнопка назад на странице товара
    elements.productBackBtn?.addEventListener('click', () => {
        closeProductPage();
    });
    
    // Количество в модалке
    elements.qtyMinus?.addEventListener('click', () => updateQuantity(-1));
    elements.qtyPlus?.addEventListener('click', () => updateQuantity(1));
    
    // Добавить в корзину
    elements.addToCartBtn?.addEventListener('click', addToCart);
    
    // Избранное в модалке
    elements.productFavoriteBtn?.addEventListener('click', () => {
        if (state.currentProduct) {
            toggleFavorite(state.currentProduct.id);
        }
    });
    
    // Фильтры
    if (elements.filterBtn) {
        elements.filterBtn.addEventListener('click', () => {
            openFilterModal();
        });
    }
    if (elements.closeFilterModal) {
        elements.closeFilterModal.addEventListener('click', closeFilterModal);
    }
    if (elements.applyFilters) {
        elements.applyFilters.addEventListener('click', applyFilters);
    }
    if (elements.resetFilters) {
        elements.resetFilters.addEventListener('click', resetFilters);
    }
    
    // Навигация
    console.log('[EVENTS] Setting up navigation...');
    elements.bottomNav?.addEventListener('click', (e) => {
        console.log('[CLICK] Bottom nav clicked', e.target);
        const navItem = e.target.closest('.nav-item');
        if (navItem) {
            console.log('[NAV] Navigating to:', navItem.dataset.page);
            navigateTo(navItem.dataset.page);
        }
    });
    
    // Кнопки Header
    console.log('[EVENTS] Setting up header buttons...');
    elements.favoritesBtn?.addEventListener('click', () => {
        console.log('[CLICK] Favorites button clicked');
        navigateTo('favorites');
    });
    elements.cartBtn?.addEventListener('click', () => {
        console.log('[CLICK] Cart button clicked');
        navigateTo('cart');
    });
    
    // Корзина
    elements.clearCartBtn?.addEventListener('click', clearCart);
    elements.checkoutBtn?.addEventListener('click', checkout);
    
    // Обработчики модального окна оформления заказа
    const checkoutModal = document.getElementById('checkoutModal');
    const closeCheckoutModalBtns = document.querySelectorAll('[id^="closeCheckoutModal"]');
    closeCheckoutModalBtns.forEach(btn => {
        btn.addEventListener('click', closeCheckoutModal);
    });
    
    // Кнопки возврата на предыдущий шаг
    document.querySelectorAll('.back-to-step').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const step = parseInt(e.currentTarget.dataset.step);
            showCheckoutStep(step);
        });
    });
    
    // Закрытие модального окна при клике на фон
    if (checkoutModal) {
        checkoutModal.addEventListener('click', (e) => {
            if (e.target.id === 'checkoutModal') {
                closeCheckoutModal();
            }
        });
    }
    
    // Кнопки "Назад"
    document.querySelectorAll('[data-back]').forEach(btn => {
        btn.addEventListener('click', () => navigateTo(btn.dataset.back));
    });
    
    // Кнопка "Назад" на странице магазина
    const shopBackBtn = document.getElementById('shopBackBtn');
    if (shopBackBtn) {
        shopBackBtn.addEventListener('click', () => {
            // Если открыли из страницы товара, возвращаемся туда
            if (state.currentProduct) {
                navigateTo('product');
            } else {
                navigateTo('catalog');
            }
        });
    }
    
    // ============ My Orders ============
    
    // Открыть страницу заказов
    elements.myOrdersBtn?.addEventListener('click', () => navigateTo('myorders'));
    
    // ============ My Shop ============
    
    // Открыть страницу магазина
    elements.myShopBtn?.addEventListener('click', () => navigateTo('myshop'));
    
    // Настройки
    elements.settingsBtn?.addEventListener('click', () => navigateTo('settings'));
    
    // Помощь
    elements.helpBtn?.addEventListener('click', () => navigateTo('help'));
    
    // Сохранение настроек
    elements.saveSettingsBtn?.addEventListener('click', saveSettings);
    
    // Очистка кэша
    elements.clearCacheBtn?.addEventListener('click', clearCache);
    
    // Счётчик символов в описании
    elements.shopDescription?.addEventListener('input', (e) => {
        elements.descCharCount.textContent = e.target.value.length;
    });
    
    // Загрузка фото магазина
    elements.shopPhotoUpload?.addEventListener('click', () => {
        elements.shopPhoto.click();
    });
    
    elements.shopPhoto?.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                elements.shopPhotoPreview.innerHTML = `<img src="${e.target.result}" alt="Preview">`;
            };
            reader.readAsDataURL(file);
        }
    });
    
    // Форма создания магазина
    elements.shopCreateForm?.addEventListener('submit', handleCreateShop);
    
    // Кнопки управления магазином
    elements.editShopBtn?.addEventListener('click', openEditShopModal);
    elements.closeEditShopModal?.addEventListener('click', () => {
        elements.editShopModal.hidden = true;
    });
    elements.shopEditForm?.addEventListener('submit', handleUpdateShop);
    
    // Загрузка фото магазина в форме редактирования
    const editShopPhotoUpload = document.getElementById('editShopPhotoUpload');
    const editShopPhoto = document.getElementById('editShopPhoto');
    const editShopPhotoPreview = document.getElementById('editShopPhotoPreview');
    
    if (editShopPhotoUpload && editShopPhoto) {
        editShopPhotoUpload.addEventListener('click', () => {
            editShopPhoto.click();
        });
        
        editShopPhoto.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Проверяем тип файла
                if (!file.type.startsWith('image/')) {
                    showToast('Выберите изображение', 'error');
                    return;
                }
                
                // Проверяем размер (макс 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    showToast('Файл слишком большой (максимум 5MB)', 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (editShopPhotoPreview) {
                        editShopPhotoPreview.innerHTML = `<img src="${e.target.result}" alt="Preview">`;
                    }
                };
                reader.readAsDataURL(file);
            }
        });
    }
    
    // Подписки
    elements.manageSubscriptionBtn?.addEventListener('click', () => navigateTo('subscription-management'));
    elements.closeSubscriptionModal?.addEventListener('click', () => {
        elements.subscriptionModal.hidden = true;
        cancelSubscribeConfirm();
    });
    
    // Подтверждение подписки
    document.getElementById('cancelConfirmBtn')?.addEventListener('click', cancelSubscribeConfirm);
    document.getElementById('confirmSubscribeBtn')?.addEventListener('click', confirmSubscribe);
    
    // Закрытие модалки подписки по клику на фон
    elements.subscriptionModal?.addEventListener('click', (e) => {
        if (e.target.id === 'subscriptionModal') {
            elements.subscriptionModal.hidden = true;
            cancelSubscribeConfirm();
        }
    });
    
    // Товары
    elements.addProductBtn?.addEventListener('click', () => openAddProductModal());
    elements.addProductFromListBtn?.addEventListener('click', () => openAddProductModal());
    elements.addFirstProductBtn?.addEventListener('click', () => openAddProductModal());
    elements.closeAddProductModal?.addEventListener('click', () => {
        elements.addProductModal.hidden = true;
        resetProductForm();
    });
    elements.addProductForm?.addEventListener('submit', handleAddProduct);
    
    // Закрытие модалки по клику на фон
    document.getElementById('addProductModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'addProductModal') {
            elements.addProductModal.hidden = true;
            resetProductForm();
        }
    });
    
    // Мои товары
    elements.myProductsBtn?.addEventListener('click', () => navigateTo('myproducts'));
    
    // Заказы и отзывы магазина
    document.getElementById('shopOrdersBtn')?.addEventListener('click', () => {
        if (state.myShop) {
            navigateTo('shoporders');
        }
    });
    
    document.getElementById('shopReviewsBtn')?.addEventListener('click', () => {
        if (state.myShop) {
            navigateTo('shopreviews');
        }
    });
    
    document.getElementById('shopStatisticsBtn')?.addEventListener('click', () => {
        if (state.myShop) {
            navigateTo('shopstatistics');
        }
    });
}

// ==================== Actions ====================

// Функции selectCategory и findCategory перенесены в modules/catalog.js
// Функции openProductPage, closeProductPage, loadSellerProducts, initGalleryNavigation, changeGallerySlide, goToGallerySlide, updateQuantity, addToCart перенесены в modules/product.js

// ==================== Shop Page ====================
// Функции openShopPage, loadShopData, loadShopMap, loadShopReviews, loadShopProducts перенесены в modules/shop.js

// ==================== Checkout ====================
// Функции openProductPage, closeProductPage, loadSellerProducts, initGalleryNavigation, changeGallerySlide, goToGallerySlide, updateQuantity, addToCart перенесены в modules/product.js

// Константа стоимости доставки
const DELIVERY_FEE = 500;

let checkoutState = {
    step: 1,
    phone: null,
    address: null,
    addressIsValid: null, // null - не проверено, true - валиден, false - невалиден
    latitude: null,
    longitude: null,
    recipientName: '',
    deliveryComment: '',
    deliveryDate: null,
    deliveryTime: null,
    shopId: null,
    shopCity: null, // Город магазина для валидации адреса
    items: []
};

// Функции openShopPage, loadShopData, loadShopMap, loadShopReviews, loadShopProducts перенесены в modules/shop.js
// Функции closeProductPage, updateQuantity, addToCart уже были перенесены в modules/product.js

async function checkout() {
    if (state.cart.length === 0) {
        showToast('Корзина пуста', 'error');
        return;
    }
    
    // Группируем товары по магазинам
    const shops = {};
    state.cart.forEach(item => {
        if (!shops[item.shop_id]) {
            shops[item.shop_id] = [];
        }
        shops[item.shop_id].push(item);
    });
    
    // Если товары из разных магазинов, показываем ошибку
    const shopIds = Object.keys(shops);
    if (shopIds.length > 1) {
        showToast('Товары из разных магазинов. Оформите заказы отдельно', 'error');
        return;
    }
    
    // Получаем информацию о магазине (для определения города)
    const shopId = parseInt(shopIds[0]);
    let shopCity = null;
    
    try {
        const shop = await api.getShop(shopId);
        if (shop && shop.address) {
            // Извлекаем город из адреса магазина
            const addressLower = shop.address.toLowerCase();
            if (addressLower.includes('санкт-петербург') || addressLower.includes('спб') || addressLower.includes('сп')) {
                shopCity = 'Санкт-Петербург';
            } else if (addressLower.includes('москва') || addressLower.includes('мск')) {
                shopCity = 'Москва';
            } else {
                // Пытаемся найти название города в адресе
                const cityMatch = shop.address.match(/(?:г\.|город|город\s+)?([А-Я][а-я]+)/);
                if (cityMatch && cityMatch[1]) {
                    shopCity = cityMatch[1];
                }
            }
        }
    } catch (error) {
        console.error('Error fetching shop info:', error);
    }
    
    // Если город не определен, используем Санкт-Петербург по умолчанию
    if (!shopCity) {
        shopCity = 'Санкт-Петербург';
    }
    
    // Инициализируем состояние оформления
    checkoutState = {
        step: 1,
        phone: null,
        address: null,
        addressIsValid: null, // null - не проверено, true - валиден, false - невалиден
        latitude: null,
        longitude: null,
        recipientName: '',
        deliveryComment: '',
        deliveryDate: null,
        deliveryTime: null,
        shopId: shopId,
        shopCity: shopCity,
        items: shops[shopIds[0]].map(item => ({
            product_id: item.product_id,
            quantity: item.quantity
        }))
    };
    
    // Очищаем все blob URL перед открытием модалки (чтобы избежать конфликтов)
    cleanupAllBlobUrls();
    
    // Открываем модальное окно
    const modal = document.getElementById('checkoutModal');
    if (modal) {
        modal.hidden = false;
        showCheckoutStep(1);
    }
}

// Функция для очистки всех blob URL в документе
function cleanupAllBlobUrls() {
    // Очищаем все video и img элементы с blob URL
    document.querySelectorAll('video[src^="blob:"], img[src^="blob:"], source[src^="blob:"]').forEach(el => {
        try {
            if (el.src && el.src.startsWith('blob:')) {
                URL.revokeObjectURL(el.src);
                el.src = '';
            }
        } catch (e) {
            // Игнорируем ошибки
        }
    });
}

function showCheckoutStep(step) {
    console.log(`[CHECKOUT] showCheckoutStep called with step: ${step}`);
    checkoutState.step = step;
    
    // Скрываем все шаги
    document.querySelectorAll('.checkout-step').forEach(s => {
        s.hidden = true;
    });
    
    // Показываем нужный шаг
    const stepEl = document.getElementById(`checkoutStep${step}`);
    if (stepEl) {
        stepEl.hidden = false;
        console.log(`[CHECKOUT] Step ${step} element shown`);
    } else {
        console.error(`[CHECKOUT] Step ${step} element not found!`);
    }
    
    // Инициализируем шаг
    if (step === 1) {
        initCheckoutStep1();
    } else if (step === 2) {
        initCheckoutStep2();
    } else if (step === 3) {
        console.log('[CHECKOUT] About to call initCheckoutStep3()');
        initCheckoutStep3();
    } else if (step === 4) {
        initCheckoutStep4();
    }
}

function initCheckoutStep1() {
    const requestPhoneBtn = document.getElementById('requestPhoneBtn');
    const phoneDisplay = document.getElementById('phoneDisplay');
    const phoneNumber = document.getElementById('phoneNumber');
    const changePhoneBtn = document.getElementById('changePhoneBtn');
    const nextBtn = document.getElementById('checkoutNext1');
    
    // Проверяем, есть ли уже номер
    if (checkoutState.phone) {
        phoneDisplay.hidden = false;
        requestPhoneBtn.style.display = 'none';
        phoneNumber.textContent = checkoutState.phone;
        nextBtn.disabled = false;
    } else {
        phoneDisplay.hidden = true;
        requestPhoneBtn.style.display = 'block';
        nextBtn.disabled = true;
    }
    
    // Обработчик запроса номера через Telegram
    if (requestPhoneBtn) {
        requestPhoneBtn.onclick = async () => {
            if (window.Telegram && window.Telegram.WebApp) {
                // Пробуем получить номер из данных пользователя Telegram
                const user = window.Telegram.WebApp.initDataUnsafe?.user;
                
                if (user && user.phone_number) {
                    // Номер уже есть в данных пользователя
                    checkoutState.phone = user.phone_number;
                    phoneDisplay.hidden = false;
                    requestPhoneBtn.style.display = 'none';
                    phoneNumber.textContent = user.phone_number;
                    nextBtn.disabled = false;
                } else {
                    // Показываем поле для ввода номера
                    requestPhoneManually();
                }
            } else {
                // Fallback: просим ввести номер вручную
                requestPhoneManually();
            }
        };
    }
    
    function requestPhoneManually() {
        // Создаем инпут для номера телефона
        const phoneInput = document.createElement('input');
        phoneInput.type = 'tel';
        phoneInput.placeholder = '+79991234567';
        phoneInput.style.cssText = 'width: 100%; padding: 12px; margin-top: 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 1rem;';
        phoneInput.value = checkoutState.phone || '';
        
        const container = requestPhoneBtn.parentElement;
        const existingInput = container.querySelector('.phone-manual-input');
        if (existingInput) {
            existingInput.remove();
        }
        
        container.appendChild(phoneInput);
        phoneInput.classList.add('phone-manual-input');
        phoneInput.focus();
        
        const updatePhone = () => {
            const phone = phoneInput.value.trim();
            if (phone && phone.length >= 10) {
                checkoutState.phone = phone;
                phoneDisplay.hidden = false;
                requestPhoneBtn.style.display = 'none';
                phoneNumber.textContent = phone;
                nextBtn.disabled = false;
                phoneInput.remove();
            } else {
                showToast('Введите корректный номер телефона', 'error');
            }
        };
        
        phoneInput.addEventListener('blur', updatePhone);
        phoneInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                updatePhone();
            }
        });
    }
    
    // Кнопка изменения номера
    if (changePhoneBtn) {
        changePhoneBtn.onclick = () => {
            checkoutState.phone = null;
            phoneDisplay.hidden = true;
            requestPhoneBtn.style.display = 'block';
            nextBtn.disabled = true;
        };
    }
    
    // Кнопка "Далее"
    if (nextBtn) {
        nextBtn.onclick = () => {
            if (checkoutState.phone) {
                showCheckoutStep(2);
            }
        };
    }
}

function initCheckoutStep2() {
    const mapContainer = document.getElementById('deliveryMapContainer');
    const addressInput = document.getElementById('deliveryAddress');
    const recipientNameInput = document.getElementById('recipientName');
    const deliveryCommentInput = document.getElementById('deliveryComment');
    const useCurrentLocationBtn = document.getElementById('useCurrentLocationBtn');
    const nextBtn = document.getElementById('checkoutNext2');
    
    // Загружаем карту
    loadDeliveryMap(mapContainer, addressInput);
    
    // Показываем уведомление о зоне доставки
    const deliveryZoneNotice = document.getElementById('deliveryZoneNotice');
    const shopCityName = document.getElementById('shopCityName');
    if (deliveryZoneNotice && checkoutState.shopCity) {
        deliveryZoneNotice.hidden = false;
        if (shopCityName) {
            shopCityName.textContent = checkoutState.shopCity;
        }
    }
    
    // Заполняем данные, если они есть
    if (checkoutState.address) {
        addressInput.value = checkoutState.address;
    }
    if (checkoutState.recipientName) {
        recipientNameInput.value = checkoutState.recipientName;
    }
    if (checkoutState.deliveryComment) {
        deliveryCommentInput.value = checkoutState.deliveryComment;
    }
    
    // Инициализируем автодополнение адресов
    initAddressAutocomplete(addressInput);
    
    // Валидация адреса по городу (текстовая проверка)
    function validateAddressText(address) {
        if (!address || !address.trim()) return false;
        
        const addressLower = address.toLowerCase();
        const cityLower = checkoutState.shopCity.toLowerCase();
        
        // Проверяем различные варианты названия города
        const cityVariants = [
            cityLower,
            cityLower.replace('санкт-петербург', 'спб'),
            cityLower.replace('санкт-петербург', 'сп'),
            cityLower.replace('москва', 'мск'),
            'санкт-петербург',
            'спб',
            'сп',
            'москва',
            'мск'
        ];
        
        // Проверяем, содержит ли адрес название города
        return cityVariants.some(variant => addressLower.includes(variant));
    }
    
    // Валидация адреса с учетом API проверки
    function isAddressValid() {
        const address = addressInput.value.trim();
        if (!address || address.length === 0) return false;
        
        // Если есть результат проверки через API, используем его
        if (checkoutState.addressIsValid !== null) {
            return checkoutState.addressIsValid === true;
        }
        
        // Если нет проверки через API, используем текстовую проверку как fallback
        return validateAddressText(address);
    }
    
    // Валидация шага 2
    function validateStep2() {
        const address = addressInput.value.trim();
        const hasAddress = address.length > 0;
        const hasRecipient = recipientNameInput.value.trim().length > 0;
        const isAddressValidResult = isAddressValid();
        
        // Кнопка "Далее" активна только если есть адрес, имя получателя и адрес валиден
        nextBtn.disabled = !(hasAddress && hasRecipient && isAddressValidResult);
        
        // Показываем предупреждение, если адрес невалиден
        if (hasAddress && !isAddressValidResult) {
            // Если есть проверка через API и адрес невалиден, показываем сообщение
            if (checkoutState.addressIsValid === false) {
                if (!addressInput.dataset.warningShown) {
                    showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                    addressInput.dataset.warningShown = 'true';
                }
            } else if (!validateAddressText(address)) {
                // Если адрес не проходит текстовую проверку
                if (!addressInput.dataset.warningShown) {
                    showToast(`⚠️ Доставка возможна только в ${checkoutState.shopCity}. Проверьте адрес`, 'warning');
                    addressInput.dataset.warningShown = 'true';
                }
            }
        } else {
            addressInput.dataset.warningShown = '';
        }
    }
    
    // Делаем функцию доступной глобально для автодополнения
    window.validateStep2Checkout = validateStep2;
    
    validateStep2();
    
    // Обработчики изменений
    addressInput.addEventListener('input', () => {
        checkoutState.address = addressInput.value;
        // При ручном вводе сбрасываем валидность адреса (потребуется проверка через геокодирование)
        checkoutState.addressIsValid = null;
        validateStep2();
    });
    
    recipientNameInput.addEventListener('input', () => {
        checkoutState.recipientName = recipientNameInput.value;
        validateStep2();
    });
    
    deliveryCommentInput.addEventListener('input', () => {
        checkoutState.deliveryComment = deliveryCommentInput.value;
    });
    
    // Использование текущего местоположения
    if (useCurrentLocationBtn) {
        useCurrentLocationBtn.onclick = () => {
            if (navigator.geolocation) {
                useCurrentLocationBtn.disabled = true;
                useCurrentLocationBtn.textContent = 'Определение...';
                
                        navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        checkoutState.latitude = lat;
                        checkoutState.longitude = lng;
                        
                        // Получаем адрес по координатам через наш бэкенд
                        try {
                            const response = await fetch(
                                `/api/geocode/reverse?lat=${lat}&lng=${lng}${checkoutState.shopCity ? `&city=${encodeURIComponent(checkoutState.shopCity)}` : ''}`
                            );
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data.address) {
                                    // Проверяем, что адрес в нужном городе
                                    if (data.is_valid) {
                                        checkoutState.address = data.address;
                                        checkoutState.addressIsValid = true; // Адрес валиден
                                        addressInput.value = data.address;
                                    } else {
                                        checkoutState.addressIsValid = false; // Адрес невалиден
                                        showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                                        checkoutState.address = data.address;
                                        addressInput.value = data.address;
                                    }
                                } else {
                                    // Если не получилось, используем координаты
                                    checkoutState.address = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                                    addressInput.value = checkoutState.address;
                                }
                            } else {
                                // Если API не доступен, используем координаты
                                checkoutState.address = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                                addressInput.value = checkoutState.address;
                            }
                            
                            validateStep2();
                        } catch (error) {
                            console.error('Reverse geocoding error:', error);
                            // При ошибке используем координаты, но предупреждаем
                            checkoutState.address = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                            addressInput.value = checkoutState.address;
                            showToast('Введите адрес вручную для проверки города', 'info');
                            validateStep2();
                        }
                        
                        useCurrentLocationBtn.disabled = false;
                        useCurrentLocationBtn.innerHTML = `
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Использовать текущее местоположение
                        `;
                    },
                    (error) => {
                        showToast('Не удалось определить местоположение', 'error');
                        useCurrentLocationBtn.disabled = false;
                        useCurrentLocationBtn.innerHTML = `
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Использовать текущее местоположение
                        `;
                    }
                );
            } else {
                showToast('Геолокация не поддерживается', 'error');
            }
        };
    }
    
    // Кнопка "Далее"
    if (nextBtn) {
        nextBtn.onclick = () => {
            const address = addressInput.value.trim();
            const recipient = recipientNameInput.value.trim();
            
            checkoutState.address = address;
            checkoutState.recipientName = recipient;
            checkoutState.deliveryComment = deliveryCommentInput.value;
            
            // Валидация перед переходом
            if (!address || !recipient) {
                showToast('Заполните все обязательные поля', 'error');
                return;
            }
            
            // Проверяем валидность адреса
            if (!isAddressValid()) {
                // Если адрес был проверен через API и невалиден
                if (checkoutState.addressIsValid === false) {
                    showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                } else {
                    // Если адрес не прошел текстовую проверку
                    showToast(`⚠️ Доставка возможна только в ${checkoutState.shopCity}. Проверьте адрес`, 'error');
                }
                return;
            }
            
            showCheckoutStep(3);
        };
    }
}

function initCheckoutStep3() {
    console.log('[CHECKOUT STEP 3] Initializing step 3...');
    
    const deliveryDateInput = document.getElementById('deliveryDate');
    const deliveryTimeSelect = document.getElementById('deliveryTime');
    const nextBtn = document.getElementById('checkoutNext3');
    
    console.log('[CHECKOUT STEP 3] Elements found:', {
        deliveryDateInput: !!deliveryDateInput,
        deliveryTimeSelect: !!deliveryTimeSelect,
        nextBtn: !!nextBtn
    });
    
    // Функция для получения доступных временных интервалов
    function getAvailableTimeSlots(selectedDate) {
        const slots = [
            { value: '09:00-12:00', start: 9, end: 12 },
            { value: '12:00-15:00', start: 12, end: 15 },
            { value: '15:00-18:00', start: 15, end: 18 },
            { value: '18:00-21:00', start: 18, end: 21 }
        ];
        
        if (!selectedDate) {
            return slots;
        }
        
        const selected = new Date(selectedDate + 'T00:00:00');
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const selectedDateOnly = new Date(selected);
        selectedDateOnly.setHours(0, 0, 0, 0);
        
        // Если выбрана сегодняшняя дата, фильтруем прошедшие интервалы
        if (selectedDateOnly.getTime() === today.getTime()) {
            const now = new Date();
            const currentHour = now.getHours();
            
            return slots.filter(slot => {
                // Если текущее время позже конца интервала, скрываем его
                return slot.end > currentHour;
            });
        }
        
        // Для будущих дат все интервалы доступны
        return slots;
    }
    
    // Функция обновления списка временных интервалов
    function updateTimeSlots(selectedDate) {
        if (!deliveryTimeSelect) return;
        
        const availableSlots = getAvailableTimeSlots(selectedDate);
        const currentValue = deliveryTimeSelect.value;
        
        // Очищаем список
        deliveryTimeSelect.innerHTML = '<option value="">Выберите время</option>';
        
        // Добавляем доступные интервалы
        availableSlots.forEach(slot => {
            const option = document.createElement('option');
            option.value = slot.value;
            option.textContent = slot.value;
            deliveryTimeSelect.appendChild(option);
        });
        
        // Восстанавливаем выбранное значение, если оно доступно
        if (currentValue && availableSlots.some(s => s.value === currentValue)) {
            deliveryTimeSelect.value = currentValue;
            checkoutState.deliveryTime = currentValue;
        } else {
            // Если выбранное время больше недоступно, сбрасываем
            deliveryTimeSelect.value = '';
            checkoutState.deliveryTime = null;
        }
        
        validateStep3();
    }
    
    // Устанавливаем минимальную дату (сегодня)
    if (deliveryDateInput) {
        const today = new Date();
        const minDate = today.toISOString().split('T')[0];
        deliveryDateInput.min = minDate;
        
        // Устанавливаем значение, если уже выбрано
        if (checkoutState.deliveryDate) {
            deliveryDateInput.value = checkoutState.deliveryDate;
        }
        
        // Инициализируем список временных интервалов
        updateTimeSlots(deliveryDateInput.value);
        
        // Обновляем состояние при изменении даты
        deliveryDateInput.addEventListener('change', () => {
            const selectedDate = deliveryDateInput.value;
            checkoutState.deliveryDate = selectedDate;
            
            // Обновляем список временных интервалов
            updateTimeSlots(selectedDate);
        });
    }
    
    if (deliveryTimeSelect) {
        // Устанавливаем значение, если уже выбрано и доступно
        if (checkoutState.deliveryTime) {
            const availableSlots = getAvailableTimeSlots(checkoutState.deliveryDate);
            if (availableSlots.some(s => s.value === checkoutState.deliveryTime)) {
                deliveryTimeSelect.value = checkoutState.deliveryTime;
            }
        }
        
        // Обновляем состояние при изменении времени
        deliveryTimeSelect.addEventListener('change', () => {
            checkoutState.deliveryTime = deliveryTimeSelect.value;
            validateStep3();
        });
    }
    
    function validateStep3() {
        let isValid = checkoutState.deliveryDate && checkoutState.deliveryTime;
        let errorMessage = '';
        
        if (!checkoutState.deliveryDate) {
            errorMessage = 'Выберите дату доставки';
        } else if (!checkoutState.deliveryTime) {
            errorMessage = 'Выберите время доставки';
        } else {
            // Проверяем, что выбранное время не в прошлом
            const selectedDate = new Date(checkoutState.deliveryDate + 'T00:00:00');
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const selectedDateOnly = new Date(selectedDate);
            selectedDateOnly.setHours(0, 0, 0, 0);
            
            if (selectedDateOnly.getTime() === today.getTime()) {
                // Если выбрана сегодняшняя дата, проверяем время
                const timeSlot = checkoutState.deliveryTime.split('-')[0]; // Берем начальное время
                const [hours, minutes] = timeSlot.split(':').map(Number);
                const selectedDateTime = new Date();
                selectedDateTime.setHours(hours, minutes, 0, 0);
                
                if (selectedDateTime < new Date()) {
                    isValid = false;
                    errorMessage = 'Выбранное время уже прошло. Выберите другое время';
                }
            }
        }
        
        // Получаем актуальную ссылку на кнопку (на случай, если она была заменена)
        const currentBtn = document.getElementById('checkoutNext3') || nextBtn;
        
        if (currentBtn) {
            currentBtn.disabled = !isValid;
            // Сохраняем сообщение об ошибке для отображения
            currentBtn.dataset.errorMessage = errorMessage;
            console.log('[CHECKOUT STEP 3] Button state:', {
                disabled: currentBtn.disabled,
                isValid: isValid,
                errorMessage: errorMessage
            });
        }
        
        return isValid;
    }
    
    // Изначальная валидация
    validateStep3();
    
    // Кнопка "Далее" - используем прямой обработчик с задержкой
    setTimeout(() => {
        const currentBtn = document.getElementById('checkoutNext3');
        if (!currentBtn) {
            console.error('[CHECKOUT STEP 3] ❌ Next button not found after timeout!');
            return;
        }
        
        console.log('[CHECKOUT STEP 3] ✅ Found button, setting up handler');
        
        // Функция-обработчик
        const handleClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = true;
            
            console.log('[CHECKOUT STEP 3] ✅✅✅ BUTTON CLICKED!');
            
            const isValid = validateStep3();
            console.log('[CHECKOUT STEP 3] Validation result:', isValid);
            
            if (isValid) {
                console.log('[CHECKOUT STEP 3] ✅ Moving to step 4');
                showCheckoutStep(4);
            } else {
                const btn = document.getElementById('checkoutNext3');
                const errorMsg = (btn && btn.dataset.errorMessage) || 'Заполните все поля';
                console.log('[CHECKOUT STEP 3] ❌ Error:', errorMsg);
                showToast(errorMsg, 'error');
            }
            
            return false;
        };
        
        // Удаляем все старые обработчики - заменяем кнопку
        const newBtn = currentBtn.cloneNode(true);
        currentBtn.parentNode.replaceChild(newBtn, currentBtn);
        
        // Получаем новую ссылку
        const btn = document.getElementById('checkoutNext3');
        if (!btn) {
            console.error('[CHECKOUT STEP 3] ❌ Button not found after clone!');
            return;
        }
        
        // Устанавливаем onclick (самый надежный способ)
        btn.onclick = handleClick;
        
        // Также добавляем через addEventListener
        btn.addEventListener('click', handleClick, false);
        
        console.log('[CHECKOUT STEP 3] ✅ Handlers added to button');
    }, 150);
    
    console.log('[CHECKOUT STEP 3] Initialization complete');
}

function initCheckoutStep4() {
    // Заполняем информацию для подтверждения
    const confirmPhone = document.getElementById('confirmPhone');
    const confirmRecipient = document.getElementById('confirmRecipient');
    const confirmAddress = document.getElementById('confirmAddress');
    const confirmComment = document.getElementById('confirmComment');
    const confirmCommentRow = document.getElementById('confirmCommentRow');
    const confirmDeliveryDate = document.getElementById('confirmDeliveryDate');
    const confirmDeliveryTime = document.getElementById('confirmDeliveryTime');
    const orderItemsSummary = document.getElementById('orderItemsSummary');
    const confirmItemsCount = document.getElementById('confirmItemsCount');
    const confirmSubtotal = document.getElementById('confirmSubtotal');
    const confirmDiscount = document.getElementById('confirmDiscount');
    const confirmDiscountRow = document.getElementById('confirmDiscountRow');
    const confirmTotal = document.getElementById('confirmTotal');
    
    // Контактная информация
    if (confirmPhone) confirmPhone.textContent = checkoutState.phone || 'Не указан';
    if (confirmRecipient) confirmRecipient.textContent = checkoutState.recipientName || 'Не указано';
    if (confirmAddress) confirmAddress.textContent = checkoutState.address || 'Не указан';
    
    if (checkoutState.deliveryComment) {
        if (confirmComment) confirmComment.textContent = checkoutState.deliveryComment;
        if (confirmCommentRow) confirmCommentRow.hidden = false;
    } else {
        if (confirmCommentRow) confirmCommentRow.hidden = true;
    }
    
    // Дата и время доставки
    console.log('[CHECKOUT STEP 4] Delivery info:', {
        deliveryDate: checkoutState.deliveryDate,
        deliveryTime: checkoutState.deliveryTime,
        confirmDeliveryDate: !!confirmDeliveryDate,
        confirmDeliveryTime: !!confirmDeliveryTime
    });
    
    if (confirmDeliveryDate) {
        if (checkoutState.deliveryDate) {
            // Парсим дату правильно (формат YYYY-MM-DD из input[type="date"])
            const dateParts = checkoutState.deliveryDate.split('-');
            if (dateParts.length === 3) {
                // Создаем дату в локальном времени (месяц - 1, так как в JS месяцы 0-11)
                const date = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                const formattedDate = date.toLocaleDateString('ru-RU', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                });
                confirmDeliveryDate.textContent = formattedDate;
                console.log('[CHECKOUT STEP 4] ✅ Date formatted:', formattedDate);
            } else {
                // Если формат другой, пытаемся распарсить как есть
                try {
                    const date = new Date(checkoutState.deliveryDate);
                    if (!isNaN(date.getTime())) {
                        const formattedDate = date.toLocaleDateString('ru-RU', {
                            day: 'numeric',
                            month: 'long',
                            year: 'numeric'
                        });
                        confirmDeliveryDate.textContent = formattedDate;
                    } else {
                        confirmDeliveryDate.textContent = checkoutState.deliveryDate;
                    }
                } catch (e) {
                    confirmDeliveryDate.textContent = checkoutState.deliveryDate;
                }
            }
        } else {
            confirmDeliveryDate.textContent = 'Не указана';
            console.log('[CHECKOUT STEP 4] ❌ No delivery date in state');
        }
    } else {
        console.error('[CHECKOUT STEP 4] ❌ confirmDeliveryDate element not found!');
    }
    
    if (confirmDeliveryTime) {
        if (checkoutState.deliveryTime) {
            confirmDeliveryTime.textContent = checkoutState.deliveryTime;
            console.log('[CHECKOUT STEP 4] ✅ Time set:', checkoutState.deliveryTime);
        } else {
            confirmDeliveryTime.textContent = 'Не указано';
            console.log('[CHECKOUT STEP 4] ❌ No delivery time in state');
        }
    } else {
        console.error('[CHECKOUT STEP 4] ❌ confirmDeliveryTime element not found!');
    }
    
    // Товары в заказе
    const items = state.cart.filter(item => item.shop_id === checkoutState.shopId);
    if (orderItemsSummary) {
        orderItemsSummary.innerHTML = items.map(item => {
            const hasDiscount = item.product_discount_price && item.product_discount_price < item.product_price;
            const price = hasDiscount ? item.product_discount_price : item.product_price;
            const imageUrl = getMediaUrl(item.product_image_url || '');
            
            return `
                <div class="order-item-summary">
                    <div class="order-item-image">
                        ${item.product_image_url 
                            ? `<img src="${imageUrl}" alt="${item.product_name}">`
                            : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;">🌸</div>'
                        }
                    </div>
                    <div class="order-item-details">
                        <div class="order-item-name">${item.product_name}</div>
                        <div class="order-item-meta">
                            <span>${item.quantity} шт.</span>
                            <span class="order-item-price">${formatPrice(price * item.quantity)}</span>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // Итоги
    const count = items.reduce((sum, item) => sum + item.quantity, 0);
    const subtotal = items.reduce((sum, item) => sum + (parseFloat(item.product_price) * item.quantity), 0);
    const itemsTotal = items.reduce((sum, item) => {
        const price = item.product_discount_price || item.product_price;
        return sum + (parseFloat(price) * item.quantity);
    }, 0);
    const discount = subtotal - itemsTotal;
    const deliveryFee = DELIVERY_FEE;
    const total = itemsTotal + deliveryFee;
    
    if (confirmItemsCount) confirmItemsCount.textContent = count;
    if (confirmSubtotal) confirmSubtotal.textContent = formatPrice(subtotal);
    if (confirmTotal) confirmTotal.textContent = formatPrice(total);
    
    // Отображаем доставку
    const confirmDeliveryFee = document.getElementById('confirmDeliveryFee');
    if (confirmDeliveryFee) {
        confirmDeliveryFee.textContent = formatPrice(deliveryFee);
    }
    
    if (discount > 0) {
        if (confirmDiscount) confirmDiscount.textContent = formatPrice(discount);
        if (confirmDiscountRow) confirmDiscountRow.hidden = false;
    } else {
        if (confirmDiscountRow) confirmDiscountRow.hidden = true;
    }
    
    // Кнопка подтверждения
    const submitBtn = document.getElementById('submitOrderBtn');
    if (submitBtn) {
        submitBtn.onclick = submitOrder;
    }
}

let deliveryMap = null;
let deliveryMapPlacemark = null;

// Функция для добавления обработчика перетаскивания маркера
function addMarkerDragHandler(placemark, addressInput) {
    if (!placemark || placemark._dragHandlerAdded) return;
    
    placemark.events.add('dragend', async () => {
        const newCoords = placemark.geometry.getCoordinates();
        // Yandex Maps возвращает координаты маркера в формате [долгота, широта] = [lng, lat]
        const newLng = newCoords[0]; // Долгота
        const newLat = newCoords[1]; // Широта
        
        console.log('[MAP] Marker dragged to:', { lng: newLng, lat: newLat });
        
        checkoutState.latitude = newLat;
        checkoutState.longitude = newLng;
        
        // Получаем новый адрес
        try {
            const dragResponse = await fetch(
                `/api/geocode/reverse?lat=${newLat}&lng=${newLng}${checkoutState.shopCity ? `&city=${encodeURIComponent(checkoutState.shopCity)}` : ''}`
            );
            
            if (dragResponse.ok) {
                const dragData = await dragResponse.json();
                if (dragData.address) {
                    checkoutState.address = dragData.address;
                    checkoutState.addressIsValid = dragData.is_valid === true; // Устанавливаем валидность из API
                    addressInput.value = dragData.address;
                    
                    // Если адрес невалиден, показываем уведомление
                    if (!dragData.is_valid) {
                        showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                    }
                    
                    // Если адрес валиден, обновляем свойства маркера
                    if (dragData.is_valid) {
                    
                        placemark.properties.set({
                            balloonContent: dragData.address,
                            iconCaption: dragData.address
                        });
                    }
                    
                    const validateStep2 = window.validateStep2Checkout;
                    if (validateStep2) {
                        validateStep2();
                    }
                }
            }
        } catch (error) {
            console.error('Reverse geocoding error on drag:', error);
        }
    });
    
    placemark._dragHandlerAdded = true;
}

function loadDeliveryMap(container, addressInput) {
    if (!container) {
        console.error('[MAP] Container not found');
        return;
    }
    
    // Определяем координаты города для карты
    // Формат: [широта, долгота] = [lat, lng] - будут перевернуты для Yandex Maps
    let center = [59.939095, 30.315868]; // Санкт-Петербург по умолчанию [lat, lng]
    let city = checkoutState.shopCity || 'Санкт-Петербург';
    
    console.log('[MAP] Shop city from checkoutState:', city);
    
    // Настройки для разных городов [долгота, широта]
    const cityLower = (city || '').toLowerCase();
    if (cityLower.includes('москва')) {
        center = [55.7558, 37.6173]; // Москва [lat, lng] - будут перевернуты для Yandex Maps
        console.log('[MAP] Using Moscow coordinates:', center);
    } else if (cityLower.includes('санкт-петербург') || cityLower.includes('спб') || cityLower.includes('питер')) {
        center = [59.939095, 30.315868]; // Центр Санкт-Петербурга [lat, lng] - будут перевернуты для Yandex Maps
        console.log('[MAP] Using Saint Petersburg coordinates:', center);
    } else if (cityLower.includes('казань')) {
        center = [55.796127, 49.105177]; // Казань [lat, lng]
        console.log('[MAP] Using Kazan coordinates:', center);
    } else {
        // По умолчанию Санкт-Петербург
        center = [59.939095, 30.315868]; // [lat, lng] - будут перевернуты для Yandex Maps
        console.log('[MAP] Using default Saint Petersburg coordinates:', center, '(city not recognized)');
    }
    
    console.log('[MAP] Final center coordinates for map:', center, '(format: [lat, lng], will be reversed to [lng, lat] for Yandex Maps)');
    
    // Уничтожаем предыдущую карту если она существует
    if (deliveryMap) {
        try {
            deliveryMap.destroy();
            deliveryMap = null;
            deliveryMapPlacemark = null;
        } catch (e) {
            console.warn('[MAP] Error destroying previous map:', e);
        }
    }
    
    // Создаем контейнер для карты
    container.innerHTML = `
        <div id="deliveryMap" style="width: 100%; height: 300px; border-radius: 12px; overflow: hidden;"></div>
        <p style="margin-top: 8px; font-size: 0.875rem; color: var(--text-secondary);">
            💡 Нажмите на карту, чтобы выбрать адрес доставки
        </p>
    `;
    
    const mapElement = document.getElementById('deliveryMap');
    if (!mapElement) {
        console.error('[MAP] Map element not created');
        return;
    }
    
    // Проверяем, загружена ли Yandex Maps API
    if (typeof ymaps === 'undefined') {
        console.log('[MAP] Yandex Maps API not loaded, loading...');
        // Загружаем API ключ с бэкенда и затем загружаем Yandex Maps API
        loadYandexMapsAPI(mapElement, center, addressInput);
    } else {
        console.log('[MAP] Yandex Maps API already loaded, initializing map...');
        // Небольшая задержка, чтобы убедиться, что контейнер готов
        setTimeout(() => {
            initDeliveryMap(mapElement, center, addressInput);
        }, 100);
    }
}

// Загружает Yandex Maps API с ключом
async function loadYandexMapsAPI(mapElement, center, addressInput) {
    try {
        console.log('[MAP] Loading Yandex Maps API...');
        
        // Получаем API ключ с бэкенда
        const configResponse = await fetch('/api/config');
        let apiKey = '';
        
        if (configResponse.ok) {
            const config = await configResponse.json();
            apiKey = config.yandex_api_key || '';
            console.log('[MAP] API key received:', apiKey ? 'Yes (length: ' + apiKey.length + ')' : 'No');
        } else {
            console.warn('[MAP] Failed to fetch config:', configResponse.status);
        }
        
        // Проверяем, нет ли уже загруженного скрипта Yandex Maps
        const existingScript = document.querySelector('script[src*="api-maps.yandex.ru"]');
        if (existingScript) {
            console.log('[MAP] Yandex Maps script already exists, removing...');
            existingScript.remove();
        }
        
        // Формируем URL для загрузки Yandex Maps API
        let scriptUrl = 'https://api-maps.yandex.ru/2.1/?lang=ru_RU';
        if (apiKey) {
            scriptUrl += `&apikey=${encodeURIComponent(apiKey)}`;
        }
        
        console.log('[MAP] Loading script from:', scriptUrl.replace(apiKey, 'API_KEY_HIDDEN'));
        
        // Загружаем скрипт
        const script = document.createElement('script');
        script.src = scriptUrl;
        script.onload = () => {
            console.log('[MAP] Script loaded successfully, initializing map...');
            setTimeout(() => {
                initDeliveryMap(mapElement, center, addressInput);
            }, 100);
        };
        script.onerror = (error) => {
            console.error('[MAP] Failed to load script:', error);
            // Если API не загрузился, показываем сообщение
            mapElement.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; text-align: center; padding: 20px;">
                    <div>
                        <p>Карта временно недоступна</p>
                        <p style="font-size: 0.875rem; margin-top: 8px;">Используйте поле ввода адреса выше</p>
                        <p style="font-size: 0.75rem; margin-top: 8px; color: #999;">Проверьте API ключ Yandex Maps в настройках</p>
                    </div>
                </div>
            `;
        };
        document.head.appendChild(script);
    } catch (error) {
        console.error('Error loading Yandex Maps API key:', error);
        // Загружаем без ключа (может не работать)
        const script = document.createElement('script');
        script.src = 'https://api-maps.yandex.ru/2.1/?lang=ru_RU';
        script.onload = () => {
            initDeliveryMap(mapElement, center, addressInput);
        };
        script.onerror = () => {
            mapElement.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; text-align: center; padding: 20px;">
                    <div>
                        <p>Карта временно недоступна</p>
                        <p style="font-size: 0.875rem; margin-top: 8px;">Используйте поле ввода адреса выше</p>
                    </div>
                </div>
            `;
        };
        document.head.appendChild(script);
    }
}

function initDeliveryMap(mapElement, center, addressInput) {
    if (typeof ymaps === 'undefined') {
        console.error('[MAP] ymaps is undefined, cannot initialize map');
        return;
    }
    
    // Проверяем, что элемент существует
    const mapContainer = document.getElementById('deliveryMap');
    if (!mapContainer) {
        console.error('[MAP] Map container not found');
        return;
    }
    
    // Инициализируем карту
    ymaps.ready(() => {
        try {
            // Удаляем предыдущую карту, если она существует
            if (deliveryMap) {
                try {
                    deliveryMap.destroy();
                } catch (e) {
                    console.warn('[MAP] Error destroying previous map:', e);
                }
                deliveryMap = null;
                deliveryMapPlacemark = null;
            }
            
            // Проверяем, что контейнер все еще существует
            const checkContainer = document.getElementById('deliveryMap');
            if (!checkContainer) {
                console.error('[MAP] Map container disappeared before initialization');
                return;
            }
            
            // Yandex Maps использует формат [долгота, широта] для center
            // center в формате [широта, долгота] = [lat, lng], нужно поменять местами для Yandex Maps
            const mapCenter = [center[1], center[0]]; // Меняем местами: [lng, lat] = [долгота, широта]
            
            console.log('[MAP] Initializing map at center:', mapCenter, '(format: [lng, lat] from [lat, lng]:', center, ')');
            console.log('[MAP] Shop city:', checkoutState.shopCity);
            
            deliveryMap = new ymaps.Map('deliveryMap', {
                center: mapCenter, // Yandex Maps ожидает [долгота, широта]
                zoom: 12,
                controls: ['zoomControl', 'geolocationControl']
            });
            
            // Явно устанавливаем центр карты после инициализации для надежности
            deliveryMap.setCenter(mapCenter, 12);
            
            console.log('[MAP] Map initialized successfully at center:', mapCenter);
        
            // Обработчик клика на карту
            deliveryMap.events.add('click', async (e) => {
                try {
                    const coords = e.get('coords');
                    // ВАЖНО: Yandex Maps JS API возвращает координаты клика в формате [долгота, широта] = [lng, lat]
                    // Согласно документации Yandex Maps: e.get('coords') всегда возвращает [lng, lat]
                    // Для СПб: coords = [30.37, 59.93] = [lng, lat]
                    const lng = coords[0]; // Долгота
                    const lat = coords[1]; // Широта
                    
                    console.log('[MAP] Click detected at:', { 
                        raw_coords: coords,
                        lng: lng, 
                        lat: lat,
                        note: 'Format: [lng, lat] from Yandex Maps API'
                    });
                    
                    // Сохраняем координаты (lat - широта, lng - долгота)
                    checkoutState.latitude = lat;
                    checkoutState.longitude = lng;
                    
                    // Получаем адрес по координатам
                    try {
                        const url = `/api/geocode/reverse?lat=${lat}&lng=${lng}${checkoutState.shopCity ? `&city=${encodeURIComponent(checkoutState.shopCity)}` : ''}`;
                        console.log('[MAP] Requesting reverse geocoding:', url);
                        
                        const response = await fetch(url);
                        console.log('[MAP] Response status:', response.status, response.statusText);
                        
                        let data;
                        try {
                            data = await response.json();
                            console.log('[MAP] Reverse geocoding response:', data);
                        } catch (e) {
                            console.error('[MAP] Failed to parse JSON response:', e);
                            const text = await response.text();
                            console.error('[MAP] Response text:', text);
                            showToast('Ошибка при получении ответа от сервера', 'error');
                            return;
                        }
                        
                        // Проверяем наличие адреса в ответе
                        if (data && data.address) {
                            // Проверяем, что адрес в нужном городе
                            if (data.is_valid !== false) {
                                checkoutState.address = data.address;
                                checkoutState.addressIsValid = true; // Адрес валиден
                                if (addressInput) {
                                    addressInput.value = data.address;
                                }
                                console.log('[MAP] Address set and marked as valid:', data.address);
                                
                                // Обновляем маркер на карте
                                if (deliveryMapPlacemark) {
                                    deliveryMap.geoObjects.remove(deliveryMapPlacemark);
                                }
                                
                                // Yandex Maps использует [долгота, широта]
                                deliveryMapPlacemark = new ymaps.Placemark(
                                    [lng, lat],
                                    {
                                        balloonContent: data.address,
                                        iconCaption: data.address
                                    },
                                    {
                                        preset: 'islands#blueDotIcon',
                                        draggable: true
                                    }
                                );
                                
                                deliveryMap.geoObjects.add(deliveryMapPlacemark);
                                
                                // Добавляем обработчик перетаскивания маркера
                                addMarkerDragHandler(deliveryMapPlacemark, addressInput);
                                
                                // Валидируем адрес
                                const validateStep2 = window.validateStep2Checkout;
                                if (validateStep2) {
                                    validateStep2();
                                }
                                
                                showToast('Адрес выбран на карте', 'success');
                            } else {
                                console.warn('[MAP] Address is invalid (outside delivery zone):', data.address);
                                checkoutState.addressIsValid = false; // Адрес невалиден
                                checkoutState.address = data.address; // Сохраняем адрес для отображения
                                checkoutState.latitude = lat;
                                checkoutState.longitude = lng;
                                if (addressInput) {
                                    addressInput.value = data.address;
                                }
                                // Валидируем шаг, чтобы заблокировать кнопку "Далее"
                                const validateStep2 = window.validateStep2Checkout;
                                if (validateStep2) {
                                    validateStep2();
                                }
                                showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                            }
                        } else {
                            // Нет адреса в ответе или ошибка
                            const errorMsg = data?.error || 'Не удалось определить адрес для выбранной точки';
                            console.warn('[MAP] No address in response:', data);
                            showToast(errorMsg, 'warning');
                        }
                    } catch (error) {
                        console.error('[MAP] Reverse geocoding error:', error);
                        showToast('Ошибка при получении адреса: ' + (error.message || 'Неизвестная ошибка'), 'error');
                    }
                } catch (error) {
                    console.error('[MAP] Error handling map click:', error);
                }
            });
        
        // Если есть сохраненные координаты И они валидны, показываем маркер
        // Но карта уже центрирована на городе магазина, поэтому не меняем центр
        if (checkoutState.latitude && checkoutState.longitude && checkoutState.addressIsValid === true) {
            // Yandex Maps использует [долгота, широта]
            deliveryMapPlacemark = new ymaps.Placemark(
                [checkoutState.longitude, checkoutState.latitude],
                {
                    balloonContent: checkoutState.address || 'Выбранный адрес',
                    iconCaption: checkoutState.address || 'Адрес'
                },
                {
                    preset: 'islands#blueDotIcon',
                    draggable: true
                }
            );
            
            deliveryMap.geoObjects.add(deliveryMapPlacemark);
            // НЕ меняем центр карты - она уже центрирована на городе магазина
            // Если пользователь хочет увидеть свой сохраненный адрес, он может найти его на карте
            
            // Добавляем обработчик перетаскивания
            addMarkerDragHandler(deliveryMapPlacemark, addressInput);
        }
        
        } catch (error) {
            console.error('[MAP] Error initializing map:', error);
            mapContainer.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; text-align: center; padding: 20px;">
                    <div>
                        <p>Ошибка загрузки карты</p>
                        <p style="font-size: 0.875rem; margin-top: 8px;">Используйте поле ввода адреса выше</p>
                    </div>
                </div>
            `;
        }
    });
}

// Автодополнение адресов через Яндекс Suggest API
function initAddressAutocomplete(input) {
    const suggestionsContainer = document.getElementById('addressSuggestions');
    if (!input || !suggestionsContainer) return;
    
    let timeoutId = null;
    let currentCity = checkoutState.shopCity || 'Санкт-Петербург';
    
    input.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        
        // Очищаем предыдущий таймер
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        
        // Если пусто, скрываем подсказки
        if (query.length < 3) {
            suggestionsContainer.hidden = true;
            suggestionsContainer.innerHTML = '';
            return;
        }
        
        // Ждем 300мс после последнего ввода перед запросом
        timeoutId = setTimeout(async () => {
            try {
                // Используем наш бэкенд эндпоинт для автодополнения адресов
                // Это решает проблемы с CORS и необходимостью API ключа
                const url = `/api/geocode/autocomplete?query=${encodeURIComponent(query)}&city=${encodeURIComponent(currentCity)}&limit=5`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response && response.ok) {
                    const data = await response.json();
                    const suggestions = data.suggestions || [];
                    
                    if (suggestions.length > 0) {
                        displaySuggestions(suggestions);
                    } else {
                        // Если нет подходящих, не показываем подсказки (пользователь может ввести вручную)
                        suggestionsContainer.hidden = true;
                    }
                } else {
                    // Если API недоступен, не показываем подсказки
                    suggestionsContainer.hidden = true;
                }
            } catch (error) {
                console.log('Address autocomplete error:', error);
                // При ошибке не показываем подсказки
                suggestionsContainer.hidden = true;
            }
        }, 300);
    });
    
    // Функция для обновления карты по адресу
    async function updateMapByAddress(address) {
        if (!address || address.trim().length === 0) return;
        
        // Получаем функцию валидации один раз для всей функции
        const validateStep2 = window.validateStep2Checkout;
        
        try {
            const url = `/api/geocode/geocode?address=${encodeURIComponent(address)}${currentCity ? `&city=${encodeURIComponent(currentCity)}` : ''}`;
            console.log('[MAP] Geocoding address:', url);
            
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                console.log('[MAP] Geocoding response:', data);
                
                if (data.coordinates) {
                    // Координаты из бэкенда: lat - широта, lng - долгота
                    const lat = data.coordinates.lat;
                    const lng = data.coordinates.lng;
                    
                    console.log('[MAP] Setting marker at:', { lng, lat, address, is_valid: data.is_valid });
                    
                    checkoutState.latitude = lat;
                    checkoutState.longitude = lng;
                    checkoutState.addressIsValid = data.is_valid === true; // Устанавливаем валидность из API
                    
                    // Валидируем шаг после получения результата
                    if (validateStep2) {
                        validateStep2();
                    }
                    
                    // Если адрес невалиден, не ставим маркер и не центрируем карту
                    if (!data.is_valid || !deliveryMap || typeof ymaps === 'undefined') {
                        if (!data.is_valid) {
                            console.warn('[MAP] Address is invalid, not placing marker');
                            showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                        }
                        return;
                    }
                    
                    // Удаляем предыдущий маркер
                    if (deliveryMapPlacemark) {
                        deliveryMap.geoObjects.remove(deliveryMapPlacemark);
                    }
                    
                    // Создаем новый маркер
                    // Yandex Maps ожидает координаты в формате [долгота, широта] = [lng, lat]
                    deliveryMapPlacemark = new ymaps.Placemark(
                        [lng, lat],  // [долгота, широта]
                        {
                            balloonContent: address,
                            iconCaption: address
                        },
                        {
                            preset: 'islands#blueDotIcon',
                            draggable: true
                        }
                    );
                    
                    deliveryMap.geoObjects.add(deliveryMapPlacemark);
                    deliveryMap.setCenter([lng, lat], 15);
                    
                    console.log('[MAP] Marker placed and map centered');
                    
                    // Добавляем обработчик перетаскивания маркера
                    addMarkerDragHandler(deliveryMapPlacemark, input);
                } else {
                    console.warn('[MAP] Geocoding failed or invalid:', data);
                    checkoutState.addressIsValid = false; // Адрес невалиден или не найден
                    showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                    if (validateStep2) {
                        validateStep2();
                    }
                }
            } else {
                const errorText = await response.text().catch(() => 'Unknown error');
                console.error('[MAP] Geocoding request failed:', response.status, errorText);
                checkoutState.addressIsValid = false; // Адрес невалиден при ошибке запроса
                showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                if (validateStep2) {
                    validateStep2();
                }
            }
        } catch (error) {
            console.error('[MAP] Error updating map by address:', error);
            checkoutState.addressIsValid = false; // При ошибке помечаем как невалидный
            showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
            if (validateStep2) {
                validateStep2();
            }
        }
    }
    
    // Обработка Enter в поле ввода
    input.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const address = input.value.trim();
            if (address.length >= 3) {
                suggestionsContainer.hidden = true;
                await updateMapByAddress(address);
                // validateStep2 уже вызывается внутри updateMapByAddress
            }
        }
    });
    
    // Скрываем подсказки при потере фокуса (с небольшой задержкой для клика)
    input.addEventListener('blur', async () => {
        setTimeout(async () => {
            suggestionsContainer.hidden = true;
            
            // Обновляем карту при потере фокуса, если адрес введен
            const address = input.value.trim();
            if (address.length >= 5) {
                await updateMapByAddress(address);
            }
        }, 200);
    });
    
    // Показываем подсказки при фокусе, если есть текст
    input.addEventListener('focus', () => {
        if (input.value.trim().length >= 3 && suggestionsContainer.children.length > 0) {
            suggestionsContainer.hidden = false;
        }
    });
    
    function displaySuggestions(suggestions) {
        if (suggestions.length === 0) {
            suggestionsContainer.hidden = true;
            return;
        }
        
        suggestionsContainer.innerHTML = suggestions.map((suggestion, index) => {
            const address = suggestion.title || suggestion.text || '';
            return `
                <div class="address-suggestion-item" data-address="${address}" data-index="${index}">
                    <span class="suggestion-icon">📍</span>
                    <span class="suggestion-text">${address}</span>
                </div>
            `;
        }).join('');
        
        // Добавляем обработчики кликов
        suggestionsContainer.querySelectorAll('.address-suggestion-item').forEach(item => {
            item.addEventListener('click', async () => {
                const address = item.dataset.address;
                input.value = address;
                checkoutState.address = address;
                suggestionsContainer.hidden = true;
                
                // Получаем координаты адреса и обновляем карту
                try {
                    const response = await fetch(
                        `/api/geocode/geocode?address=${encodeURIComponent(address)}${currentCity ? `&city=${encodeURIComponent(currentCity)}` : ''}`
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('[MAP] Geocoding response for selected address:', data);
                        
                        if (data.coordinates) {
                            // Координаты из API: lat - широта, lng - долгота
                            const lat = data.coordinates.lat;
                            const lng = data.coordinates.lng;
                            
                            checkoutState.latitude = lat;
                            checkoutState.longitude = lng;
                            checkoutState.addressIsValid = data.is_valid === true; // Устанавливаем валидность из API
                            
                            console.log('[MAP] Setting marker for selected address:', { lng, lat, address, is_valid: data.is_valid });
                            
                            // Если адрес невалиден, не обновляем карту
                            if (!data.is_valid) {
                                console.warn('[MAP] Address is invalid, not updating map');
                                showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                                // Валидируем шаг (кнопка "Далее" должна быть отключена)
                                const validateStep2 = window.validateStep2Checkout;
                                if (validateStep2) {
                                    validateStep2();
                                }
                                return;
                            }
                            
                            // Обновляем карту и маркер, если карта уже инициализирована
                            if (deliveryMap && typeof ymaps !== 'undefined') {
                                // Удаляем предыдущий маркер
                                if (deliveryMapPlacemark) {
                                    deliveryMap.geoObjects.remove(deliveryMapPlacemark);
                                }
                                
                                // Создаем новый маркер
                                // Yandex Maps ожидает координаты в формате [долгота, широта] = [lng, lat]
                                deliveryMapPlacemark = new ymaps.Placemark(
                                    [lng, lat],  // [долгота, широта]
                                    {
                                        balloonContent: address,
                                        iconCaption: address
                                    },
                                    {
                                        preset: 'islands#blueDotIcon',
                                        draggable: true
                                    }
                                );
                                
                                deliveryMap.geoObjects.add(deliveryMapPlacemark);
                                deliveryMap.setCenter([lng, lat], 15);
                                
                                console.log('[MAP] Marker placed and map centered for selected address');
                                
                                // Добавляем обработчик перетаскивания маркера
                                addMarkerDragHandler(deliveryMapPlacemark, input);
                            } else {
                                console.warn('[MAP] Map not initialized yet, coordinates saved for later');
                            }
                        } else {
                            console.warn('[MAP] Invalid coordinates or address outside delivery zone:', data);
                            checkoutState.addressIsValid = false; // Адрес невалиден
                            showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                            // Валидируем шаг (кнопка "Далее" должна быть отключена)
                            const validateStep2 = window.validateStep2Checkout;
                            if (validateStep2) {
                                validateStep2();
                            }
                        }
                    } else {
                        console.error('[MAP] Geocoding request failed:', response.status);
                        checkoutState.addressIsValid = false; // Адрес невалиден при ошибке
                        showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                    }
                } catch (error) {
                    console.error('Geocoding error:', error);
                    checkoutState.addressIsValid = false; // Адрес невалиден при ошибке
                    showToast(`❌ Нельзя выбрать такой адрес. Доставка возможна только в ${checkoutState.shopCity}`, 'error');
                }
                
                // Валидируем адрес
                const validateStep2 = window.validateStep2Checkout;
                if (validateStep2) {
                    validateStep2();
                }
            });
        });
        
        suggestionsContainer.hidden = false;
    }
    
    function displaySimpleSuggestions(query, city) {
        // Если запрос слишком короткий, не показываем подсказки
        if (query.length < 2) {
            suggestionsContainer.hidden = true;
            return;
        }
        
        // Простые подсказки на основе города и запроса
        // Генерируем варианты с разными типами улиц
        const queryLower = query.toLowerCase();
        const streetTypes = ['ул.', 'улица', 'пр.', 'проспект', 'пер.', 'переулок', 'пл.', 'площадь', 'б-р', 'бульвар', 'ш.', 'шоссе'];
        
        // Проверяем, не начинается ли запрос уже с типа улицы
        const hasStreetType = streetTypes.some(type => queryLower.startsWith(type));
        
        const commonAddresses = [];
        
        if (!hasStreetType) {
            // Добавляем варианты с разными типами улиц
            streetTypes.forEach(type => {
                const fullType = type.endsWith('.') ? type : type + ' ';
                commonAddresses.push(`${city}, ${fullType}${query}`);
            });
        } else {
            // Если уже есть тип улицы, просто добавляем город
            commonAddresses.push(`${city}, ${query}`);
        }
        
        // Ограничиваем количество подсказок
        const limitedAddresses = commonAddresses.slice(0, 5);
        
        suggestionsContainer.innerHTML = limitedAddresses.map((addr, index) => `
            <div class="address-suggestion-item" data-address="${addr}" data-index="${index}">
                <span class="suggestion-icon">📍</span>
                <span class="suggestion-text">${addr}</span>
            </div>
        `).join('');
        
        // Добавляем обработчики
        suggestionsContainer.querySelectorAll('.address-suggestion-item').forEach(item => {
            item.addEventListener('click', () => {
                const address = item.dataset.address;
                input.value = address;
                checkoutState.address = address;
                suggestionsContainer.hidden = true;
                
                const validateStep2 = window.validateStep2Checkout;
                if (validateStep2) {
                    validateStep2();
                }
            });
        });
        
        suggestionsContainer.hidden = false;
    }
}

async function submitOrder() {
    const submitBtn = document.getElementById('submitOrderBtn');
    const submitBtnText = document.getElementById('submitOrderBtnText');
    const submitBtnLoading = document.getElementById('submitOrderBtnLoading');
    
    if (!submitBtn || submitBtn.disabled) return;
    
    // Блокируем кнопку
    submitBtn.disabled = true;
    submitBtnText.hidden = true;
    submitBtnLoading.hidden = false;
    
    try {
        // Создаём заказ
        const orderData = {
            shop_id: checkoutState.shopId,
            items: checkoutState.items,
            recipient_phone: checkoutState.phone,
            recipient_name: checkoutState.recipientName,
            delivery_address: checkoutState.address,
            delivery_date: checkoutState.deliveryDate || null,
            delivery_time_slot: checkoutState.deliveryTime || null,
            comment: checkoutState.deliveryComment || null,
            payment_method: 'cash' // По умолчанию наличные
        };
        
        const order = await api.createOrder(orderData);
        
        showToast('Заказ успешно оформлен!', 'success');
        
        // Закрываем модальное окно
        const modal = document.getElementById('checkoutModal');
        if (modal) modal.hidden = true;
        
        // Обновляем корзину
        await loadCart();
        
        // Возвращаемся в каталог
        navigateTo('catalog');
        
    } catch (error) {
        console.error('Error creating order:', error);
        showToast('Ошибка оформления заказа: ' + (error.message || 'Неизвестная ошибка'), 'error');
        
        // Разблокируем кнопку
        submitBtn.disabled = false;
        submitBtnText.hidden = false;
        submitBtnLoading.hidden = true;
    }
}

// Функция для очистки всех blob URL в документе
function cleanupAllBlobUrls() {
    // Очищаем все video и img элементы с blob URL
    document.querySelectorAll('video[src^="blob:"], img[src^="blob:"], source[src^="blob:"]').forEach(el => {
        try {
            if (el.src && el.src.startsWith('blob:')) {
                URL.revokeObjectURL(el.src);
                el.src = '';
            }
        } catch (e) {
            // Игнорируем ошибки
        }
    });
}

function closeCheckoutModal() {
    // Очищаем все blob URL при закрытии модалки
    cleanupAllBlobUrls();
    const modal = document.getElementById('checkoutModal');
    if (modal) modal.hidden = true;
    checkoutState = {
        step: 1,
        phone: null,
        address: null,
        addressIsValid: null, // null - не проверено, true - валиден, false - невалиден
        latitude: null,
        longitude: null,
        recipientName: '',
        deliveryComment: '',
        shopId: null,
        items: []
    };
}

// ==================== Navigation ====================

// Функции navigateTo, openSearch, closeSearch, handleSearch перенесены в modules/navigation.js

// ==================== Utils ====================
// Функции getMediaUrl, formatPrice, formatDate, getOrderStatusText, updateCartBadge, updateFavoritesBadge, showLoading, showToast, debounce, pluralize перенесены в modules/utils.js

// ==================== My Shop ====================
// Все функции My Shop перенесены в modules/myshop.js

// Заглушки для обратной совместимости (если модули еще не загружены)
// Если модули загружены, используем функции из них
async function navigateTo(page) {
    // Используем функцию из модуля navigation, если доступна
    if (window.App?.navigation?.navigateTo) {
        return await window.App.navigation.navigateTo(page);
    }
    
    console.log('[NAV] Navigating to:', page);
    
    // Скрываем header при переходе на страницы (кроме каталога)
    const header = document.querySelector('.header');
    if (header) {
        header.style.display = (page === 'catalog') ? 'block' : 'none';
    }
    
    // Скрываем все страницы (включая главную)
    const mainContent = document.querySelector('.main-content');
    if (mainContent) {
        mainContent.style.display = (page === 'catalog') ? 'block' : 'none';
    }
    
    const shopOrdersPage = document.getElementById('shopOrdersPage');
    const shopReviewsPage = document.getElementById('shopReviewsPage');
    const shopStatisticsPage = document.getElementById('shopStatisticsPage');
    
    const allPages = [
        elements.productPage,
        elements.cartPage, 
        elements.favoritesPage, 
        elements.profilePage,
        elements.myShopPage,
        elements.myProductsPage,
        elements.subscriptionManagementPage,
        elements.shopPage,
        elements.settingsPage,
        elements.helpPage
    ];
    
    const myOrdersPage = document.getElementById('myOrdersPage');
    if (myOrdersPage) allPages.push(myOrdersPage);
    if (shopOrdersPage) allPages.push(shopOrdersPage);
    if (shopReviewsPage) allPages.push(shopReviewsPage);
    if (shopStatisticsPage) allPages.push(shopStatisticsPage);
    allPages.forEach(p => {
        if (p) {
            p.setAttribute('hidden', '');
            p.style.display = 'none';
        }
    });
    
    // Обновляем навигацию (только для основных страниц)
    const mainPages = ['catalog', 'favorites', 'cart', 'profile'];
    if (mainPages.includes(page)) {
        if (elements.bottomNav) {
            elements.bottomNav.querySelectorAll('.nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.page === page);
            });
        }
    }
    
    // Показываем нужную страницу
    switch (page) {
        case 'catalog':
            if (mainContent) {
                mainContent.style.display = 'block';
                mainContent.hidden = false;
            }
            if (header) header.style.display = 'block';
            window.scrollTo(0, 0);
            break;
        case 'product':
            if (elements.productPage) {
                elements.productPage.hidden = false;
                elements.productPage.style.display = 'flex';
                // Сбрасываем скролл
                setTimeout(() => {
                    elements.productPage.scrollTop = 0;
                }, 0);
            }
            break;
        case 'cart':
            if (elements.cartPage) {
                elements.cartPage.hidden = false;
                elements.cartPage.style.display = 'flex';
                setTimeout(() => {
                    elements.cartPage.scrollTop = 0;
                }, 0);
                if (window.App?.cart?.renderCart) {
                    await window.App.cart.renderCart();
                }
            }
            break;
        case 'favorites':
            if (elements.favoritesPage) {
                elements.favoritesPage.hidden = false;
                elements.favoritesPage.style.display = 'flex';
                setTimeout(() => {
                    elements.favoritesPage.scrollTop = 0;
                }, 0);
                // Всегда перезагружаем избранное при открытии страницы для актуальности данных
                try {
                    if (window.App?.favorites?.loadFavorites && window.App?.favorites?.renderFavorites) {
                        await window.App.favorites.loadFavorites();
                        await window.App.favorites.renderFavorites();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading favorites:', error);
                    // Показываем пустое состояние при ошибке
                    elements.favoritesEmpty.hidden = false;
                    elements.favoritesGrid.innerHTML = '';
                }
            }
            break;
        case 'profile':
            if (elements.profilePage) {
                elements.profilePage.removeAttribute('hidden');
                elements.profilePage.style.display = 'flex';
                setTimeout(() => {
                    elements.profilePage.scrollTop = 0;
                }, 0);
                // Проверяем наличие магазина и показываем/скрываем кнопку
                try {
                    if (window.App?.myshop?.checkAndShowMyShopButton) {
                        await window.App.myshop.checkAndShowMyShopButton();
                    }
                } catch (error) {
                    console.error('[PROFILE] Error checking shop:', error);
                    // Скрываем кнопку при ошибке
                    if (elements.myShopBtn) {
                        elements.myShopBtn.style.display = 'none';
                    }
                }
            }
            break;
        case 'myorders':
            const myOrdersPageEl = document.getElementById('myOrdersPage');
            if (myOrdersPageEl) {
                myOrdersPageEl.hidden = false;
                myOrdersPageEl.style.display = 'flex';
                setTimeout(() => {
                    myOrdersPageEl.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadUserOrders) {
                        await window.App.myshop.loadUserOrders();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading user orders:', error);
                }
            }
            break;
        case 'myshop':
            if (elements.myShopPage) {
                elements.myShopPage.hidden = false;
                elements.myShopPage.style.display = 'flex';
                setTimeout(() => {
                    elements.myShopPage.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadMyShop) {
                        await window.App.myshop.loadMyShop();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading my shop:', error);
                }
            }
            break;
        case 'shoporders':
            const shopOrdersPageEl = document.getElementById('shopOrdersPage');
            if (shopOrdersPageEl) {
                shopOrdersPageEl.hidden = false;
                shopOrdersPageEl.style.display = 'flex';
                setTimeout(() => {
                    shopOrdersPageEl.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadShopOrders) {
                        await window.App.myshop.loadShopOrders();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading shop orders:', error);
                }
            }
            break;
        case 'shopreviews':
            const shopReviewsPageEl = document.getElementById('shopReviewsPage');
            if (shopReviewsPageEl) {
                shopReviewsPageEl.hidden = false;
                shopReviewsPageEl.style.display = 'flex';
                setTimeout(() => {
                    shopReviewsPageEl.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadShopReviewsPage) {
                        await window.App.myshop.loadShopReviewsPage();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading shop reviews:', error);
                }
            }
            break;
        case 'shopstatistics':
            const shopStatisticsPageEl = document.getElementById('shopStatisticsPage');
            if (shopStatisticsPageEl) {
                shopStatisticsPageEl.hidden = false;
                shopStatisticsPageEl.style.display = 'flex';
                setTimeout(() => {
                    shopStatisticsPageEl.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadShopStatistics) {
                        await window.App.myshop.loadShopStatistics();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading shop statistics:', error);
                }
            }
            break;
        case 'myproducts':
            if (elements.myProductsPage) {
                elements.myProductsPage.hidden = false;
                elements.myProductsPage.style.display = 'flex';
                setTimeout(() => {
                    elements.myProductsPage.scrollTop = 0;
                }, 0);
                try {
                    if (window.App?.myshop?.loadMyProducts) {
                        await window.App.myshop.loadMyProducts();
                    }
                } catch (error) {
                    console.error('[NAV] Error loading my products:', error);
                }
            }
            break;
        case 'subscription-management':
            if (elements.subscriptionManagementPage) {
                elements.subscriptionManagementPage.hidden = false;
                elements.subscriptionManagementPage.style.display = 'flex';
                setTimeout(() => {
                    elements.subscriptionManagementPage.scrollTop = 0;
                }, 0);
                if (window.App?.myshop?.loadSubscriptionManagement) {
                    await window.App.myshop.loadSubscriptionManagement();
                }
            }
            break;
        case 'shop':
            if (elements.shopPage) {
                elements.shopPage.hidden = false;
                elements.shopPage.style.display = 'flex';
                setTimeout(() => {
                    elements.shopPage.scrollTop = 0;
                }, 0);
            }
            break;
        case 'settings':
            if (elements.settingsPage) {
                elements.settingsPage.removeAttribute('hidden');
                elements.settingsPage.style.display = 'flex';
                setTimeout(() => {
                    elements.settingsPage.scrollTop = 0;
                }, 0);
                if (window.App?.myshop?.loadSettings) {
                    window.App.myshop.loadSettings();
                }
            } else {
                console.error('[NAV] settingsPage element not found');
            }
            break;
        case 'help':
            if (elements.helpPage) {
                elements.helpPage.removeAttribute('hidden');
                elements.helpPage.style.display = 'flex';
                setTimeout(() => {
                    elements.helpPage.scrollTop = 0;
                }, 0);
            } else {
                console.error('[NAV] helpPage element not found');
            }
            break;
    }
}

// ==================== Search ====================

function openSearch() {
    elements.searchModal.hidden = false;
    elements.searchInput.focus();
}

function closeSearch() {
    elements.searchModal.hidden = true;
    elements.searchInput.value = '';
    elements.searchResults.innerHTML = '';
}

async function handleSearch() {
    const query = elements.searchInput.value.trim();
    
    if (query.length < 2) {
        elements.searchResults.innerHTML = '';
        return;
    }
    
    try {
        const products = await api.getProducts({ search: query, limit: 10 });
        
        if (products.length === 0) {
            elements.searchResults.innerHTML = '<div class="empty-state"><p>Ничего не найдено</p></div>';
            return;
        }
        
        elements.searchResults.innerHTML = products.map(p => `
            <div class="search-result-item" onclick="openProductPage(${p.id}); closeSearch();">
                <div style="width:48px;height:48px;background:var(--bg-tertiary);border-radius:8px;overflow:hidden;">
                    ${p.primary_image ? `<img src="${p.primary_image}" style="width:100%;height:100%;object-fit:cover;">` : '🌸'}
                </div>
                <div style="flex:1;">
                    <div style="font-weight:500;">${p.name}</div>
                    <div style="color:var(--text-muted);font-size:0.875rem;">${formatPrice(p.discount_price || p.price)}</div>
                </div>
            </div>
        `).join('');
    } catch (error) {
        console.error('Search error:', error);
    }
}

// ==================== Helpers ====================
// Все функции-утилиты (getMediaUrl, formatPrice, formatDate, getOrderStatusText, updateCartBadge, updateFavoritesBadge, showLoading, showToast, debounce) перенесены в modules/utils.js

// ==================== Demo Data ====================

function getDemoCategories() {
    return [
        { id: 1, name: 'Цветы', icon: '💐', children: [
            { id: 8, name: 'Монобукеты', icon: '🌷' },
            { id: 9, name: 'Авторские букеты', icon: '💮' },
            { id: 10, name: 'Букеты гиганты', icon: '🌸' },
        ]},
        { id: 2, name: 'Комнатные растения', icon: '🪴', children: [] },
        { id: 3, name: 'Кондитерские', icon: '🍰', children: [] },
        { id: 4, name: 'Съедобные букеты', icon: '🍓', children: [] },
        { id: 5, name: 'Вкусные наборы', icon: '🎁', children: [] },
        { id: 6, name: 'Чай и кофе', icon: '☕', children: [] },
    ];
}

function getDemoProducts() {
    return [
        { id: 1, name: 'Букет "Весенняя нежность"', price: 3500, discount_price: 2800, shop_name: 'FlowerLove', is_trending: true },
        { id: 2, name: 'Красные розы 51 шт', price: 8900, discount_price: null, shop_name: 'RoseGarden', is_trending: true },
        { id: 3, name: 'Монстера Deliciosa', price: 2200, discount_price: null, shop_name: 'GreenHome', is_trending: false },
        { id: 4, name: 'Торт "Красный бархат"', price: 2800, discount_price: 2100, shop_name: 'SweetDreams', is_trending: false },
        { id: 5, name: 'Орхидея Фаленопсис', price: 3500, discount_price: 2450, shop_name: 'OrchidWorld', is_trending: true },
        { id: 6, name: 'Набор макарун 12 шт', price: 1200, discount_price: null, shop_name: 'MacaronParis', is_trending: false },
    ];
}

// ==================== My Shop Functions ====================

async function checkAndShowMyShopButton() {
    // Проверяет наличие магазина и показывает/скрывает кнопку 'Мой магазин'.
    try {
        const shop = await api.getMyShop();
        if (shop && elements.myShopBtn) {
            // Показываем кнопку, если магазин есть
            elements.myShopBtn.style.display = 'flex';
            state.myShop = shop; // Сохраняем в state для дальнейшего использования
        } else {
            // Скрываем кнопку, если магазина нет
            if (elements.myShopBtn) {
                elements.myShopBtn.style.display = 'none';
            }
            state.myShop = null;
        }
    } catch (error) {
        // Если ошибка (например, 404 - магазин не найден), скрываем кнопку
        console.log('[PROFILE] No shop found for user');
        if (elements.myShopBtn) {
            elements.myShopBtn.style.display = 'none';
        }
        state.myShop = null;
    }
}

async function loadMyShop() {
    try {
        state.myShop = await api.getMyShop();
        state.mySubscription = await api.getMySubscription();
        renderShopPage();
    } catch (error) {
        console.error('Error loading shop:', error);
        state.myShop = null;
        state.mySubscription = null;
        renderShopPage();
    }
}

function renderShopPage() {
    if (state.myShop) {
        // Показываем панель управления
        elements.shopCreateSection.hidden = true;
        elements.shopDashboard.hidden = false;
        
        // Заполняем данные магазина
        elements.dashboardShopName.textContent = state.myShop.name;
        elements.dashboardShopRating.textContent = state.myShop.average_rating || '0.0';
        elements.dashboardReviewsCount.textContent = state.myShop.total_reviews || 0;
        elements.dashboardProductsCount.textContent = state.myShop.products_count || 0;
        elements.dashboardOrdersCount.textContent = state.myShop.orders_count || 0;
        elements.dashboardRedemptionRate.textContent = (state.myShop.redemption_rate || 0) + '%';
        
        if (state.myShop.photo_url) {
            elements.dashboardShopPhoto.innerHTML = `<img src="${state.myShop.photo_url}" alt="${state.myShop.name}">`;
        }
        
        // Подписка
        if (state.mySubscription && state.mySubscription.is_active) {
            elements.subscriptionInfo.hidden = false;
            elements.noSubscription.hidden = true;
            elements.subscriptionStatus.textContent = 'Активна';
            elements.subscriptionStatus.className = 'subscription-status active';
            elements.currentPlanName.textContent = state.mySubscription.plan_name || 'Подписка';
            elements.daysRemaining.textContent = state.mySubscription.days_remaining || 0;
        } else {
            elements.subscriptionInfo.hidden = true;
            elements.noSubscription.hidden = false;
            elements.subscriptionStatus.textContent = 'Неактивна';
            elements.subscriptionStatus.className = 'subscription-status inactive';
        }
    } else {
        // Показываем форму создания
        elements.shopCreateSection.hidden = false;
        elements.shopDashboard.hidden = true;
    }
}

async function handleCreateShop(e) {
    e.preventDefault();
    
    const name = elements.shopName.value.trim();
    const description = elements.shopDescription.value.trim();
    const address = elements.shopAddress.value.trim();
    const phone = elements.shopPhone.value.trim();
    const email = elements.shopEmail.value.trim();
    
    if (!name) {
        showToast('Введите название магазина', 'error');
        return;
    }
    
    // Показываем загрузку
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn?.textContent;
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Создание...';
    }
    
    try {
        // Подготавливаем данные (убираем пустые строки)
        const shopData = {
            name,
            description: description || null,
            address: address || null,
            phone: phone || null,
            email: email || null
        };
        
        console.log('Creating shop with data:', shopData);
        
        const shop = await api.createShop(shopData);
        
        state.myShop = shop;
        showToast('✅ Магазин успешно создан!', 'success');
        renderShopPage();
        
        // Показываем кнопку "Мой магазин" в профиле
        await checkAndShowMyShopButton();
        
        // Очищаем форму
        elements.shopCreateForm.reset();
        if (elements.shopPhotoPreview) {
            elements.shopPhotoPreview.innerHTML = '<span>📷</span><p>Нажмите для загрузки</p>';
        }
    } catch (error) {
        console.error('Error creating shop:', error);
        
        // Улучшенная обработка ошибок
        let errorMessage = 'Ошибка создания магазина';
        if (error.message) {
            if (error.message.includes('already has a shop')) {
                errorMessage = 'У вас уже есть магазин';
            } else if (error.message.includes('not found') || error.message.includes('404')) {
                errorMessage = 'Сервер недоступен. Проверьте, что сервер запущен.';
            } else if (error.message.includes('required') || error.message.includes('missing')) {
                errorMessage = 'Заполните обязательные поля';
            } else {
                errorMessage = error.message;
            }
        }
        
        showToast(errorMessage, 'error');
    } finally {
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
        }
    }
}

function openEditShopModal() {
    if (!state.myShop) return;
    
    document.getElementById('editShopName').value = state.myShop.name || '';
    document.getElementById('editShopDescription').value = state.myShop.description || '';
    document.getElementById('editShopAddress').value = state.myShop.address || '';
    document.getElementById('editShopPhone').value = state.myShop.phone || '';
    document.getElementById('editShopEmail').value = state.myShop.email || '';
    
    // Отображаем текущее фото магазина
    const editShopPhotoPreview = document.getElementById('editShopPhotoPreview');
    const editShopPhoto = document.getElementById('editShopPhoto');
    
    if (editShopPhotoPreview) {
        if (state.myShop.photo_url) {
            const photoUrl = getMediaUrl(state.myShop.photo_url);
            editShopPhotoPreview.innerHTML = `<img src="${photoUrl}" alt="Shop photo">`;
        } else {
            editShopPhotoPreview.innerHTML = '<span>📷</span><p>Нажмите для загрузки</p>';
        }
    }
    
    // Сбрасываем выбор файла
    if (editShopPhoto) {
        editShopPhoto.value = '';
    }
    
    elements.editShopModal.hidden = false;
}

async function handleUpdateShop(e) {
    e.preventDefault();
    
    const name = document.getElementById('editShopName').value.trim();
    const description = document.getElementById('editShopDescription').value.trim();
    const address = document.getElementById('editShopAddress').value.trim();
    const phone = document.getElementById('editShopPhone').value.trim();
    const email = document.getElementById('editShopEmail').value.trim();
    const editShopPhoto = document.getElementById('editShopPhoto');
    
    try {
        // Сначала загружаем фото, если оно выбрано
        let photoUrl = state.myShop.photo_url;
        if (editShopPhoto && editShopPhoto.files && editShopPhoto.files[0]) {
            console.log('[SHOP] Uploading shop photo...');
            const photoResponse = await api.uploadShopPhoto(state.myShop.id, editShopPhoto.files[0]);
            photoUrl = photoResponse.photo_url;
            console.log('[SHOP] Photo uploaded, new URL:', photoUrl);
        }
        
        // Обновляем данные магазина (включая photo_url если была загрузка)
        const updateData = {
            name,
            description,
            address,
            phone,
            email
        };
        
        // Если фото было загружено, добавляем photo_url к данным обновления
        if (photoUrl !== state.myShop.photo_url) {
            updateData.photo_url = photoUrl;
        }
        
        const shop = await api.updateShop(state.myShop.id, updateData);
        
        state.myShop = { ...state.myShop, ...shop };
        showToast('Магазин обновлён', 'success');
        elements.editShopModal.hidden = true;
        renderShopPage();
    } catch (error) {
        console.error('Error updating shop:', error);
        let errorMessage = 'Ошибка обновления';
        if (error.message) {
            if (error.message.includes('файл слишком большой')) {
                errorMessage = 'Файл слишком большой (максимум 5MB)';
            } else if (error.message.includes('неподдерживаемый тип')) {
                errorMessage = 'Неподдерживаемый тип файла. Используйте изображение (JPG, PNG, WebP)';
            } else {
                errorMessage = error.message;
            }
        }
        showToast(errorMessage, 'error');
    }
}

let pendingPlanId = null;

async function openSubscriptionModal() {
    try {
        // Загружаем планы и текущую подписку
        [state.subscriptionPlans, state.mySubscription] = await Promise.all([
            api.getSubscriptionPlans(),
            api.getMySubscription().catch(() => null) // Если ошибка, возвращаем null
        ]);
        
        renderSubscriptionPlans();
        renderCurrentSubscription();
        elements.subscriptionModal.hidden = false;
    } catch (error) {
        console.error('Error loading plans:', error);
        showToast('Ошибка загрузки тарифов', 'error');
    }
}

function renderCurrentSubscription() {
    const currentInfo = document.getElementById('currentSubscriptionInfo');
    const currentPlanName = document.getElementById('currentSubscriptionPlanName');
    const currentExpires = document.getElementById('currentSubscriptionExpires');
    
    if (state.mySubscription && state.mySubscription.is_active) {
        currentInfo.hidden = false;
        currentPlanName.textContent = state.mySubscription.plan_name || 'Подписка';
        const days = state.mySubscription.days_remaining || 0;
        currentExpires.textContent = `Истекает через: ${days} ${days === 1 ? 'день' : days < 5 ? 'дня' : 'дней'}`;
    } else {
        currentInfo.hidden = true;
    }
}

function renderSubscriptionPlans() {
    const currentPlanId = state.mySubscription?.plan_id;
    
    elements.plansList.innerHTML = state.subscriptionPlans.map(plan => {
        const isCurrent = plan.id === currentPlanId && state.mySubscription?.is_active;
        const features = typeof plan.features === 'string' ? JSON.parse(plan.features) : (plan.features || {});
        
        // Вычисляем цену за день
        const pricePerDay = plan.price / plan.duration_days;
        
        return `
            <div class="plan-card ${isCurrent ? 'current' : ''}" data-plan-id="${plan.id}">
                <div class="plan-header">
                    <h3>${plan.name}</h3>
                    <div class="plan-price">
                        <span class="amount">${formatPrice(plan.price)}</span>
                        <span class="period">/ ${plan.duration_days} ${plan.duration_days === 1 ? 'день' : 'дней'}</span>
                        ${plan.duration_days > 30 ? `<div class="price-per-day">${formatPrice(pricePerDay)}/день</div>` : ''}
                    </div>
                </div>
                ${plan.description ? `<p class="plan-description">${plan.description}</p>` : ''}
                <div class="plan-features">
                    <div class="plan-feature">
                        <span class="feature-icon">📦</span>
                        <span>До ${plan.max_products} товаров</span>
                    </div>
                    ${features.analytics ? `
                        <div class="plan-feature">
                            <span class="feature-icon">📊</span>
                            <span>Аналитика продаж</span>
                        </div>
                    ` : ''}
                    ${features.priority_support ? `
                        <div class="plan-feature">
                            <span class="feature-icon">⭐</span>
                            <span>Приоритетная поддержка</span>
                        </div>
                    ` : ''}
                    ${features.promotions ? `
                        <div class="plan-feature">
                            <span class="feature-icon">🎯</span>
                            <span>${features.promotions} промо-размещений</span>
                        </div>
                    ` : ''}
                    ${features.featured_placement ? `
                        <div class="plan-feature">
                            <span class="feature-icon">✨</span>
                            <span>Выделенное место в каталоге</span>
                        </div>
                    ` : ''}
                </div>
                <button class="select-plan-btn ${isCurrent ? 'current' : ''}" 
                        onclick="requestSubscribeToPlan(${plan.id})"
                        ${isCurrent ? 'disabled' : ''}>
                    ${isCurrent ? '✓ Текущий план' : 'Выбрать план'}
                </button>
            </div>
        `;
    }).join('');
}

function requestSubscribeToPlan(planId) {
    const plan = state.subscriptionPlans.find(p => p.id === planId);
    if (!plan) return;
    
    pendingPlanId = planId;
    
    // Показываем информацию о плане в подтверждении
    const confirmInfo = document.getElementById('confirmPlanInfo');
    const features = typeof plan.features === 'string' ? JSON.parse(plan.features) : (plan.features || {});
    
    confirmInfo.innerHTML = `
        <div class="plan-name">${plan.name}</div>
        <div class="plan-price">${formatPrice(plan.price)}</div>
        <div class="plan-duration">На ${plan.duration_days} ${plan.duration_days === 1 ? 'день' : 'дней'}</div>
        <div class="plan-features-preview" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); font-size: 0.875rem; color: var(--text-muted);">
            • До ${plan.max_products} товаров
            ${features.analytics ? '<br>• Аналитика продаж' : ''}
            ${features.priority_support ? '<br>• Приоритетная поддержка' : ''}
        </div>
    `;
    
    document.getElementById('subscriptionConfirmModal').hidden = false;
}

function cancelSubscribeConfirm() {
    pendingPlanId = null;
    document.getElementById('subscriptionConfirmModal').hidden = true;
}

async function confirmSubscribe() {
    if (!pendingPlanId) return;
    
    const confirmBtn = document.getElementById('confirmSubscribeBtn');
    const originalText = confirmBtn.textContent;
    
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'Оформление...';
    
    try {
        const subscription = await api.subscribe(pendingPlanId);
        state.mySubscription = subscription;
        
        showToast('✅ Подписка успешно оформлена!', 'success');
        document.getElementById('subscriptionConfirmModal').hidden = true;
        pendingPlanId = null;
        
        // Обновляем отображение
        await openSubscriptionModal(); // Перезагружаем данные
        renderShopPage();
    } catch (error) {
        console.error('Error subscribing:', error);
        
        // Улучшенная обработка ошибок
        let errorMessage = 'Ошибка оформления подписки';
        if (error.message) {
            if (error.message.includes('shop')) {
                errorMessage = 'Сначала создайте магазин';
            } else if (error.message.includes('not found')) {
                errorMessage = 'План подписки не найден';
            } else {
                errorMessage = error.message;
            }
        }
        
        showToast(errorMessage, 'error');
    } finally {
        confirmBtn.disabled = false;
        confirmBtn.textContent = originalText;
    }
}

// Старая функция для совместимости (перенаправляет на новую)
async function subscribeToPlan(planId) {
    requestSubscribeToPlan(planId);
}

// Состояние формы добавления товара
const productFormState = {
    photos: [],
    video: null,
    editingProductId: null, // ID товара для редактирования, null если создание
};

async function openAddProductModal(productId = null) {
    // Нормализуем productId - должен быть либо null (новый товар), либо валидное число (редактирование)
    console.log('[MODAL] openAddProductModal called with:', productId, 'type:', typeof productId);
    
    // Если значение null или undefined - оставляем null (режим создания)
    if (productId === null || productId === undefined) {
        productId = null;
    }
    // Если это объект события - игнорируем (не должно происходить после исправления обработчиков)
    else if (productId instanceof Event || (typeof productId === 'object' && productId !== null && 'target' in productId)) {
        console.warn('[MODAL] Event object passed as productId, ignoring');
        productId = null;
    }
    // Если это уже число
    else if (typeof productId === 'number') {
        // Проверяем что число валидное
        if (isNaN(productId) || !isFinite(productId) || productId <= 0) {
            console.warn('[MODAL] Invalid number passed as productId, ignoring:', productId);
            productId = null;
        }
        // Иначе оставляем как есть
    }
    // Если это строка
    else if (typeof productId === 'string') {
        const trimmed = productId.trim();
        if (trimmed === '' || trimmed === 'null' || trimmed === 'undefined') {
            productId = null;
        } else {
            const parsed = parseInt(trimmed, 10);
            if (isNaN(parsed) || !isFinite(parsed) || parsed <= 0) {
                console.warn('[MODAL] Invalid string passed as productId, ignoring:', productId);
                productId = null;
            } else {
                productId = parsed;
            }
        }
    }
    // Любое другое значение - устанавливаем null
    else {
        console.warn('[MODAL] Invalid productId type/value, ignoring:', productId, typeof productId);
        productId = null;
    }
    
    console.log('[MODAL] Opening product modal, productId:', productId);
    // Проверяем подписку
    if (!state.mySubscription || !state.mySubscription.is_active) {
        showToast('Для добавления товаров нужна подписка', 'error');
        openSubscriptionModal();
        return;
    }
    
    // Загружаем категории для селекта
    if (elements.productCategoryInput.options.length <= 1) {
        try {
            const flatCategories = await api.getCategoriesFlat();
            flatCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.parent_id ? `  └ ${cat.name}` : cat.name;
                elements.productCategoryInput.appendChild(option);
            });
        } catch (error) {
            console.error('Error loading categories:', error);
        }
    }
    
    // Устанавливаем режим редактирования или создания
    productFormState.editingProductId = productId;
    
    // Если редактирование - загружаем данные товара
    if (productId) {
        await loadProductForEdit(productId);
    } else {
        // Сбрасываем форму для создания
        resetProductForm();
    }
    
    // Обновляем заголовок модалки
    const modalTitle = document.querySelector('#addProductModal .modal-header h2');
    if (modalTitle) {
        modalTitle.textContent = productId ? 'Редактировать товар' : 'Добавить товар';
    }
    
    // Обновляем текст кнопки
    const submitBtn = document.getElementById('submitProductBtn');
    if (submitBtn) {
        const btnText = submitBtn.querySelector('.btn-text');
        if (btnText) {
            btnText.textContent = productId ? 'Сохранить изменения' : 'Добавить товар';
        } else {
            submitBtn.textContent = productId ? 'Сохранить изменения' : 'Добавить товар';
        }
    }
    
    // Инициализируем обработчики формы
    initProductFormHandlers();
    
    elements.addProductModal.hidden = false;
}

async function loadProductForEdit(productId) {
    try {
        console.log('[EDIT] Loading product for edit:', productId);
        const product = await api.getProduct(productId);
        console.log('[EDIT] Product loaded:', product);
        
        if (!product) {
            throw new Error('Товар не найден');
        }
        
        // Заполняем поля формы с проверкой существования элементов
        const nameInput = document.getElementById('productNameInput');
        const descInput = document.getElementById('productDescInput');
        const categoryInput = document.getElementById('productCategoryInput');
        const priceInput = document.getElementById('productPriceInput');
        const discountInput = document.getElementById('productDiscountInput');
        const quantityInput = document.getElementById('productQuantityInput');
        const trendingInput = document.getElementById('productTrendingInput');
        
        if (nameInput) nameInput.value = product.name || '';
        if (descInput) descInput.value = product.description || '';
        if (categoryInput) categoryInput.value = product.category_id || '';
        if (priceInput) priceInput.value = product.price || '';
        
        // Скидка
        const discountPercent = product.discount_percent || 
            (product.discount_price && product.price ? 
                Math.round((1 - product.discount_price / product.price) * 100) : null);
        if (discountInput) discountInput.value = discountPercent || '';
        
        // Количество, тренд и активность
        if (quantityInput) quantityInput.value = product.quantity || 0;
        if (trendingInput) trendingInput.checked = product.is_trending || false;
        
        // Статус активности (если есть поле)
        const activeInput = document.getElementById('productActiveInput');
        if (activeInput) {
            activeInput.checked = product.is_active !== false;
        }
        
        // Загружаем существующие медиа
        productFormState.photos = [];
        productFormState.video = null;
        
        if (product.media && Array.isArray(product.media)) {
            product.media.forEach(media => {
                // Проверяем тип медиа - может быть media_type или type
                const mediaType = media.media_type || media.type || 'photo';
                
                if (mediaType === 'photo' || mediaType === 'image') {
                    productFormState.photos.push({
                        file: null, // Файл уже на сервере
                        preview: media.url,
                        mediaId: media.id,
                        isExisting: true,
                        url: media.url // Сохраняем URL для отображения
                    });
                } else if (mediaType === 'video') {
                    productFormState.video = {
                        file: null,
                        url: media.url,
                        mediaId: media.id,
                        isExisting: true
                    };
                }
            });
            
            console.log('[EDIT] Loaded media:', {
                photos: productFormState.photos.length,
                video: productFormState.video ? 'yes' : 'no'
            });
        }
        
        // Обновляем превью
        renderPhotosPreviews();
        
        // Обновляем превью видео
        if (productFormState.video) {
            const videoElement = document.getElementById('videoElement');
            const videoPreview = document.getElementById('videoPreview');
            const videoPlaceholder = document.getElementById('videoPlaceholder');
            
            if (videoElement && productFormState.video.url) {
                // Очищаем предыдущий blob URL если есть
                if (videoElement.src && videoElement.src.startsWith('blob:')) {
                    try {
                        URL.revokeObjectURL(videoElement.src);
                    } catch (e) {
                        // Игнорируем ошибки
                    }
                }
                
                // Для существующего видео используем getMediaUrl
                // Для нового видео (blob) используем напрямую
                const videoUrl = productFormState.video.url;
                
                // Если это blob URL, используем напрямую, иначе обрабатываем через getMediaUrl
                if (videoUrl.startsWith('blob:')) {
                    videoElement.src = videoUrl;
                } else {
                    videoElement.src = getMediaUrl(videoUrl);
                }
                
                if (videoPreview) videoPreview.hidden = false;
                if (videoPlaceholder) videoPlaceholder.hidden = true;
            }
        }
        
        // Обновляем превью скидки (если функция доступна)
        if (typeof window.updateDiscountPreview === 'function') {
            window.updateDiscountPreview();
        } else {
            // Если функция еще не определена, вызываем после небольшой задержки
            setTimeout(() => {
                if (typeof window.updateDiscountPreview === 'function') {
                    window.updateDiscountPreview();
                }
            }, 100);
        }
        
    } catch (error) {
        console.error('[EDIT] Error loading product for edit:', error);
        const errorMessage = error.message || 'Ошибка загрузки товара';
        showToast(`Ошибка загрузки товара: ${errorMessage}`, 'error');
        // Не закрываем модальное окно, чтобы пользователь мог попробовать снова
        // elements.addProductModal.hidden = true;
    }
}

function resetProductForm() {
    // Очищаем все blob URL из состояния формы ПЕРЕД очисткой состояния
    productFormState.photos.forEach(photo => {
        if (photo.preview && photo.preview.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(photo.preview);
            } catch (e) {
                // Игнорируем ошибки
            }
        }
    });
    
    // Очищаем blob URL из видео
    if (productFormState.video) {
        if (productFormState.video.url && productFormState.video.url.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(productFormState.video.url);
            } catch (e) {
                // Игнорируем ошибки
            }
        }
    }
    
    productFormState.photos = [];
    productFormState.video = null;
    productFormState.editingProductId = null;
    
    // Сбрасываем форму
    const form = document.getElementById('addProductForm');
    if (form) form.reset();
    
    // Очищаем превью фото
    renderPhotosPreviews();
    
    // Очищаем видео
    const videoElement = document.getElementById('videoElement');
    const videoPreview = document.getElementById('videoPreview');
    const videoPlaceholder = document.getElementById('videoPlaceholder');
    if (videoElement) {
        // Очищаем текущий src
        if (videoElement.src && videoElement.src.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(videoElement.src);
            } catch (e) {
                // Игнорируем ошибки
            }
        }
        // Очищаем сохраненный blob URL
        if (videoElement.dataset.blobUrl) {
            try {
                URL.revokeObjectURL(videoElement.dataset.blobUrl);
            } catch (e) {
                // Игнорируем ошибки
            }
            videoElement.dataset.blobUrl = '';
        }
        videoElement.src = '';
        videoElement.load(); // Сбрасываем состояние элемента
    }
    if (videoPreview) videoPreview.hidden = true;
    if (videoPlaceholder) videoPlaceholder.hidden = false;
    
    // Сбрасываем превью скидки
    const discountPreview = document.getElementById('discountPreview');
    if (discountPreview) discountPreview.hidden = true;
}

function initProductFormHandlers() {
    // Добавление фото
    const addPhotoBtn = document.getElementById('addPhotoBtn');
    const productPhotos = document.getElementById('productPhotos');
    
    if (addPhotoBtn && productPhotos) {
        addPhotoBtn.onclick = () => productPhotos.click();
        
        productPhotos.onchange = (e) => {
            const files = Array.from(e.target.files);
            const remaining = 5 - productFormState.photos.length;
            
            if (files.length > remaining) {
                showToast(`Можно добавить ещё ${remaining} фото`, 'error');
            }
            
            files.slice(0, remaining).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    productFormState.photos.push({
                        file: file,
                        preview: e.target.result
                    });
                    renderPhotosPreviews();
                };
                reader.readAsDataURL(file);
            });
            
            productPhotos.value = '';
        };
    }
    
    // Добавление видео
    const videoUploadArea = document.getElementById('videoUploadArea');
    const productVideo = document.getElementById('productVideo');
    const videoPlaceholder = document.getElementById('videoPlaceholder');
    const removeVideoBtn = document.getElementById('removeVideoBtn');
    
    if (videoPlaceholder && productVideo) {
        videoPlaceholder.onclick = () => productVideo.click();
        
        productVideo.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            // Проверяем размер (50 МБ)
            if (file.size > 50 * 1024 * 1024) {
                showToast('Видео слишком большое (макс. 50 МБ)', 'error');
                return;
            }
            
            // Если было существующее видео, удаляем его из состояния
            const oldVideo = productFormState.video;
            if (oldVideo && oldVideo.isExisting && oldVideo.mediaId && productFormState.editingProductId) {
                // Старое видео будет удалено при сохранении, пока просто помечаем что оно заменено
                console.log('[VIDEO] Replacing existing video:', oldVideo.mediaId);
            }
            
            // Сохраняем новое видео в правильном формате
            productFormState.video = {
                file: file,
                isExisting: false,
                url: null // Будет установлен после загрузки
            };
            
            const videoElement = document.getElementById('videoElement');
            const videoPreview = document.getElementById('videoPreview');
            
            // Очищаем предыдущий blob URL, если он есть
            if (videoElement) {
                if (videoElement.src && videoElement.src.startsWith('blob:')) {
                    try {
                        URL.revokeObjectURL(videoElement.src);
                    } catch (e) {
                        // Игнорируем ошибки при очистке
                    }
                }
                
                // Очищаем сохраненный blob URL
                if (videoElement.dataset.blobUrl) {
                    try {
                        URL.revokeObjectURL(videoElement.dataset.blobUrl);
                    } catch (e) {
                        // Игнорируем ошибки
                    }
                }
                
                // Останавливаем воспроизведение перед заменой src
                videoElement.pause();
                videoElement.src = '';
                
                // Создаем новый blob URL
                const blobUrl = URL.createObjectURL(file);
                videoElement.src = blobUrl;
                videoElement.dataset.blobUrl = blobUrl;
                
                // Сохраняем blob URL в состоянии для последующей очистки
                productFormState.video.url = blobUrl;
                
                // Обработчик для очистки blob URL при ошибке загрузки
                const handleError = () => {
                    if (videoElement.dataset.blobUrl === blobUrl) {
                        try {
                            URL.revokeObjectURL(blobUrl);
                            videoElement.dataset.blobUrl = '';
                        } catch (e) {
                            // Игнорируем ошибки
                        }
                    }
                };
                
                videoElement.addEventListener('error', handleError, { once: true });
            }
            
            if (videoPreview) videoPreview.hidden = false;
            if (videoPlaceholder) videoPlaceholder.hidden = true;
        };
    }
    
    if (removeVideoBtn) {
        removeVideoBtn.onclick = async () => {
            const videoElement = document.getElementById('videoElement');
            const video = productFormState.video;
            
            // Если это существующее видео (при редактировании), удаляем его с сервера
            if (video && video.isExisting && video.mediaId && productFormState.editingProductId) {
                try {
                    await api.request(`/products/${productFormState.editingProductId}/media/${video.mediaId}`, {
                        method: 'DELETE'
                    });
                } catch (error) {
                    console.error('Error deleting video:', error);
                    // Продолжаем удаление из UI даже если ошибка
                }
            }
            
            // Очищаем blob URL, если он есть
            if (videoElement) {
                try {
                    // Останавливаем воспроизведение
                    videoElement.pause();
                    
                    // Очищаем blob URL
                    if (videoElement.src && videoElement.src.startsWith('blob:')) {
                        URL.revokeObjectURL(videoElement.src);
                    }
                    
                    // Очищаем сохраненный blob URL
                    if (videoElement.dataset.blobUrl) {
                        try {
                            URL.revokeObjectURL(videoElement.dataset.blobUrl);
                        } catch (e) {
                            // Игнорируем ошибки
                        }
                        videoElement.dataset.blobUrl = '';
                    }
                    
                    videoElement.src = '';
                    videoElement.load(); // Сбрасываем состояние элемента
                } catch (e) {
                    console.warn('Error cleaning up video blob URL:', e);
                }
            }
            
            productFormState.video = null;
            const videoPreview = document.getElementById('videoPreview');
            const videoPlaceholder = document.getElementById('videoPlaceholder');
            if (videoPreview) videoPreview.hidden = true;
            if (videoPlaceholder) videoPlaceholder.hidden = false;
        };
    }
    
    // Счётчик символов описания
    const descInput = document.getElementById('productDescInput');
    const descCharCount = document.getElementById('productDescCharCount');
    if (descInput && descCharCount) {
        descInput.oninput = () => {
            descCharCount.textContent = descInput.value.length;
        };
    }
    
    // Превью скидки
    const priceInput = document.getElementById('productPriceInput');
    const discountInput = document.getElementById('productDiscountInput');
    
    // Делаем функцию доступной глобально для использования в loadProductForEdit
    window.updateDiscountPreview = () => {
        const price = parseFloat(priceInput?.value) || 0;
        const discount = parseInt(discountInput?.value) || 0;
        const discountPreview = document.getElementById('discountPreview');
        
        if (price > 0 && discount > 0 && discountPreview) {
            const newPrice = price * (1 - discount / 100);
            const savings = price - newPrice;
            
            const oldPriceEl = document.getElementById('previewOldPrice');
            const newPriceEl = document.getElementById('previewNewPrice');
            const savingsEl = document.getElementById('previewSavings');
            
            if (oldPriceEl) oldPriceEl.textContent = formatPrice(price);
            if (newPriceEl) newPriceEl.textContent = formatPrice(newPrice);
            if (savingsEl) savingsEl.textContent = `-${formatPrice(savings)}`;
            
            discountPreview.hidden = false;
        } else if (discountPreview) {
            discountPreview.hidden = true;
        }
    };
    
    const updateDiscountPreview = window.updateDiscountPreview;
    
    if (priceInput) priceInput.oninput = updateDiscountPreview;
    if (discountInput) discountInput.oninput = updateDiscountPreview;
    
    // Кнопки +/- для количества
    const qtyInput = document.getElementById('productQuantityInput');
    const qtyDecBtn = document.getElementById('qtyDecBtn');
    const qtyIncBtn = document.getElementById('qtyIncBtn');
    
    if (qtyDecBtn && qtyInput) {
        qtyDecBtn.onclick = () => {
            const current = parseInt(qtyInput.value) || 0;
            qtyInput.value = Math.max(0, current - 1);
        };
    }
    
    if (qtyIncBtn && qtyInput) {
        qtyIncBtn.onclick = () => {
            const current = parseInt(qtyInput.value) || 0;
            qtyInput.value = current + 1;
        };
    }
    
    // Кнопка отмены
    const cancelBtn = document.getElementById('cancelAddProduct');
    if (cancelBtn) {
        cancelBtn.onclick = () => {
            elements.addProductModal.hidden = true;
        };
    }
}

function renderPhotosPreviews() {
    const grid = document.getElementById('photosGrid');
    if (!grid) return;
    
    // Очищаем всё кроме кнопки добавления
    grid.querySelectorAll('.photo-slot.preview').forEach(el => el.remove());
    
    // Добавляем превью
    productFormState.photos.forEach((photo, index) => {
        const slot = document.createElement('div');
        slot.className = 'photo-slot preview';
        // Используем правильный URL для превью (если есть url, используем его, иначе preview)
        const photoUrl = photo.url || photo.preview;
        const displayUrl = photoUrl.startsWith('blob:') || photoUrl.startsWith('http') 
            ? photoUrl 
            : getMediaUrl(photoUrl);
        
        slot.innerHTML = `
            <img src="${displayUrl}" alt="Photo ${index + 1}" loading="lazy">
            <button type="button" class="remove-photo-btn" data-index="${index}">✕</button>
            ${index === 0 ? '<span class="primary-badge">Главное</span>' : ''}
        `;
        
        slot.querySelector('.remove-photo-btn').onclick = async (e) => {
            e.stopPropagation();
            const photo = productFormState.photos[index];
            
            // Очищаем blob URL, если это blob URL
            if (photo.preview && photo.preview.startsWith('blob:')) {
                try {
                    URL.revokeObjectURL(photo.preview);
                } catch (e) {
                    // Игнорируем ошибки
                }
            }
            
            // Если это существующее фото (при редактировании), удаляем его с сервера
            if (photo.isExisting && photo.mediaId && productFormState.editingProductId) {
                try {
                    await api.request(`/products/${productFormState.editingProductId}/media/${photo.mediaId}`, {
                        method: 'DELETE'
                    });
                } catch (error) {
                    console.error('Error deleting media:', error);
                    // Продолжаем удаление из UI даже если ошибка
                }
            }
            
            productFormState.photos.splice(index, 1);
            renderPhotosPreviews();
        };
        
        // Вставляем перед кнопкой добавления
        const addBtn = document.getElementById('addPhotoBtn');
        grid.insertBefore(slot, addBtn);
    });
    
    // Скрываем кнопку если 5 фото
    const addBtn = document.getElementById('addPhotoBtn');
    if (addBtn) {
        addBtn.style.display = productFormState.photos.length >= 5 ? 'none' : '';
    }
}

async function handleAddProduct(e) {
    e.preventDefault();
    
    const name = document.getElementById('productNameInput').value.trim();
    const description = document.getElementById('productDescInput').value.trim();
    const categoryId = document.getElementById('productCategoryInput').value;
    const price = parseFloat(document.getElementById('productPriceInput').value);
    const discountPercent = parseInt(document.getElementById('productDiscountInput').value) || null;
    const quantity = parseInt(document.getElementById('productQuantityInput').value) || 0;
    const isTrending = document.getElementById('productTrendingInput').checked;
    
    // Валидация
    if (!name) {
        showToast('Введите название товара', 'error');
        return;
    }
    
    if (!categoryId) {
        showToast('Выберите категорию', 'error');
        return;
    }
    
    if (!price || price <= 0) {
        showToast('Укажите корректную цену', 'error');
        return;
    }
    
    const isEditing = !!productFormState.editingProductId;
    
    if (!isEditing && productFormState.photos.length === 0) {
        showToast('Добавьте хотя бы одно фото', 'error');
        return;
    }
    
    // При редактировании проверяем, что есть хотя бы одно фото (новое или существующее)
    if (isEditing && productFormState.photos.length === 0) {
        showToast('Добавьте хотя бы одно фото', 'error');
        return;
    }
    
    const discountPrice = discountPercent ? Math.round(price * (1 - discountPercent / 100)) : null;
    
    // Показываем загрузку
    const submitBtn = document.getElementById('submitProductBtn');
    const btnText = submitBtn.querySelector('.btn-text');
    const btnLoader = submitBtn.querySelector('.btn-loader');
    
    submitBtn.disabled = true;
    if (btnText) btnText.hidden = true;
    if (btnLoader) btnLoader.hidden = false;
    
    try {
        let productId;
        
        if (isEditing) {
            // Обновляем существующий товар
            productId = productFormState.editingProductId;
            
            // Проверяем, что productId валидный
            if (!productId || isNaN(productId)) {
                throw new Error('Неверный ID товара для редактирования');
            }
            
            console.log('[SAVE] Updating product:', productId);
            
            await api.request(`/products/${productId}`, {
                method: 'PATCH',
                body: JSON.stringify({
                    name,
                    description,
                    category_id: parseInt(categoryId),
                    price,
                    discount_price: discountPrice,
                    discount_percent: discountPercent,
                    quantity,
                    is_trending: isTrending
                })
            });
            
            // Удаляем существующие медиа, которые были удалены пользователем
            const existingMediaIds = productFormState.photos
                .filter(p => p.isExisting && p.mediaId)
                .map(p => p.mediaId);
            
            // Здесь нужно загрузить текущие медиа товара для сравнения
            // Для простоты удаляем только те, которые точно были удалены
            // (это можно улучшить, сохранив оригинальный список медиа)
        } else {
            // Создаём новый товар
            const productResponse = await api.request('/products/', {
                method: 'POST',
                body: JSON.stringify({
                    name,
                    description,
                    category_id: parseInt(categoryId),
                    price,
                    discount_price: discountPrice,
                    discount_percent: discountPercent,
                    quantity,
                    is_trending: isTrending,
                    media: [] // Сначала создаём без медиа
                })
            });
            
            productId = productResponse.id;
        }
        
        // Загружаем только новые фото (не существующие)
        const newPhotos = productFormState.photos.filter(p => !p.isExisting && p.file);
        if (newPhotos.length > 0) {
            const photoFormData = new FormData();
            let isPrimary = true;
            
            newPhotos.forEach((photo) => {
                photoFormData.append('files', photo.file);
                if (isPrimary && photo === productFormState.photos[0]) {
                    // Первое фото делаем главным
                    isPrimary = false;
                }
            });
            photoFormData.append('is_primary', productFormState.photos[0] === newPhotos[0] ? 'true' : 'false');
            
            const photoHeaders = {};
            if (api.telegramId) {
                photoHeaders['X-Telegram-ID'] = String(api.telegramId);
            }
            
            await fetch(`${api.baseUrl}/api/products/${productId}/media`, {
                method: 'POST',
                headers: photoHeaders,
                body: photoFormData
            });
        }
        
        // Загружаем видео если есть новое
        // Проверяем, является ли video файлом (старый формат) или объектом (новый формат)
        const videoToUpload = productFormState.video;
        
        if (videoToUpload) {
            let videoFile = null;
            
            // Если это просто файл (старый формат), используем его напрямую
            if (videoToUpload instanceof File) {
                videoFile = videoToUpload;
            } 
            // Если это объект с file (новый формат)
            else if (!videoToUpload.isExisting && videoToUpload.file) {
                videoFile = videoToUpload.file;
            }
            
            // Если при редактировании заменяется существующее видео, удаляем старое
            if (isEditing && videoFile) {
                try {
                    const currentProduct = await api.getProduct(productId);
                    if (currentProduct.media) {
                        const oldVideo = currentProduct.media.find(m => 
                            (m.media_type === 'video' || m.type === 'video')
                        );
                        if (oldVideo && oldVideo.id) {
                            console.log('[VIDEO] Deleting old video:', oldVideo.id);
                            try {
                                await api.request(`/products/${productId}/media/${oldVideo.id}`, {
                                    method: 'DELETE'
                                });
                                console.log('[VIDEO] Old video deleted');
                            } catch (error) {
                                console.warn('[VIDEO] Could not delete old video:', error);
                                // Продолжаем загрузку нового видео
                            }
                        }
                    }
                } catch (error) {
                    console.warn('[VIDEO] Could not fetch product to delete old video:', error);
                    // Продолжаем загрузку нового видео
                }
            }
            
            // Загружаем новое видео
            if (videoFile) {
                console.log('[VIDEO] Uploading new video for product:', productId);
                const videoFormData = new FormData();
                videoFormData.append('files', videoFile);
                
                const videoHeaders = {};
                if (api.telegramId) {
                    videoHeaders['X-Telegram-ID'] = String(api.telegramId);
                }
                
                const videoResponse = await fetch(`${api.baseUrl}/api/products/${productId}/media`, {
                    method: 'POST',
                    headers: videoHeaders,
                    body: videoFormData
                });
                
                if (!videoResponse.ok) {
                    const errorData = await videoResponse.json().catch(() => ({ detail: 'Ошибка загрузки видео' }));
                    throw new Error(errorData.detail || 'Ошибка загрузки видео');
                }
                
                console.log('[VIDEO] Video uploaded successfully');
            }
        }
        
        showToast(isEditing ? '✅ Товар успешно обновлён!' : '🎉 Товар успешно добавлен!', 'success');
        
        // Обновляем список товаров после сохранения
        if (isEditing) {
            await loadMyProducts();
        }
        elements.addProductModal.hidden = true;
        
        // Сбрасываем форму
        resetProductForm();
        
        // Обновляем данные магазина и список товаров
        await loadMyShop();
        if (isEditing) {
            await loadMyProducts();
        }
        
    } catch (error) {
        console.error('[SAVE] Error saving product:', error);
        const errorMessage = error.message || 'Ошибка сохранения товара';
        showToast(`Ошибка сохранения: ${errorMessage}`, 'error');
    } finally {
        submitBtn.disabled = false;
        if (btnText) btnText.hidden = false;
        if (btnLoader) btnLoader.hidden = true;
    }
}

// Функция для редактирования товара
async function editProduct(productId) {
    // Проверяем, что ID валидный
    if (!productId || isNaN(productId)) {
        console.error('[EDIT] Invalid product ID:', productId);
        showToast('Ошибка: неверный ID товара', 'error');
        return;
    }
    
    console.log('[EDIT] Opening edit modal for product:', productId);
    await openAddProductModal(parseInt(productId));
}

// Экспортируем функцию для использования в HTML
window.editProduct = editProduct;

async function loadMyProducts() {
    if (!state.myShop) return;
    
    try {
        console.log('[MY PRODUCTS] Loading products for shop:', state.myShop.id);
        const products = await api.request(`/shops/${state.myShop.id}/products`);
        console.log('[MY PRODUCTS] Loaded products:', products.length, 'items');
        // Убеждаемся, что is_active определено (может быть 0 или 1 в базе данных)
        state.myProducts = products.map(p => ({
            ...p,
            is_active: p.is_active !== 0 && p.is_active !== false // Нормализуем к boolean
        }));
        renderMyProducts();
    } catch (error) {
        console.error('[MY PRODUCTS] Error loading products:', error);
        state.myProducts = [];
        renderMyProducts();
    }
}

function renderMyProducts() {
    if (state.myProducts.length === 0) {
        elements.myProductsList.innerHTML = '';
        elements.myProductsEmpty.hidden = false;
        return;
    }
    
    elements.myProductsEmpty.hidden = true;
    
    elements.myProductsList.innerHTML = state.myProducts.map(product => {
        const isActive = product.is_active !== false;
        const hasDiscount = product.discount_price && product.discount_price < product.price;
        const isOutOfStock = (product.quantity || 0) === 0;
        const mediaCount = product.media ? product.media.length : (product.primary_image ? 1 : 0);
        const imageUrl = product.primary_image ? getMediaUrl(product.primary_image) : '';
        
        return `
        <div class="my-product-item ${!isActive ? 'inactive' : ''} ${isOutOfStock ? 'out-of-stock' : ''}" data-product-id="${product.id}">
            <div class="my-product-image">
                ${imageUrl 
                    ? `<img src="${imageUrl}" alt="${product.name}" loading="lazy">`
                    : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:1.5rem;background:var(--bg-tertiary);">🌸</div>'
                }
                ${!isActive ? '<div class="product-status-badge inactive-badge">Неактивен</div>' : ''}
                ${isOutOfStock ? '<div class="product-status-badge stock-badge">Нет в наличии</div>' : ''}
                ${mediaCount > 0 ? `<div class="product-media-count">📷 ${mediaCount}</div>` : ''}
            </div>
            <div class="my-product-info">
                <div class="my-product-header">
                    <div class="my-product-name" title="${product.name}">${product.name}</div>
                    ${product.is_trending ? '<span class="trending-badge">🔥</span>' : ''}
                </div>
                <div class="my-product-price-row">
                    ${hasDiscount 
                        ? `<span class="my-product-price discount">${formatPrice(product.discount_price)}</span>
                           <span class="my-product-price-old">${formatPrice(product.price)}</span>`
                        : `<span class="my-product-price">${formatPrice(product.price)}</span>`
                    }
                </div>
                <div class="my-product-stats">
                    <span title="Просмотры">👁 ${product.views_count || 0}</span>
                    <span title="Продажи">🛒 ${product.sales_count || 0}</span>
                    <span class="${isOutOfStock ? 'text-danger' : ''}" title="Количество">📦 ${product.quantity || 0} шт</span>
                </div>
            </div>
            <div class="my-product-actions">
                <button data-product-id="${product.id}" data-action="edit" title="Редактировать" class="action-btn edit-btn" type="button">✏️</button>
                <button data-product-id="${product.id}" data-action="toggle" data-current-status="${isActive}" 
                        title="${isActive ? 'Деактивировать' : 'Активировать'}" 
                        class="action-btn status-btn ${isActive ? 'active' : ''}" type="button">
                    ${isActive ? '👁️' : '👁️‍🗨️'}
                </button>
                <button data-product-id="${product.id}" data-action="delete" title="Удалить" class="action-btn delete-btn" type="button">🗑️</button>
            </div>
        </div>
        `;
    }).join('');
    
    // Добавляем обработчики событий для кнопок действий (используем делегирование)
    elements.myProductsList.querySelectorAll('[data-action]').forEach(button => {
        // Удаляем старые обработчики перед добавлением новых
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
        
        newButton.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            const productId = parseInt(newButton.dataset.productId);
            const action = newButton.dataset.action;
            
            console.log('[MY PRODUCTS] Button clicked:', action, 'productId:', productId);
            
            if (!productId || isNaN(productId)) {
                console.error('[MY PRODUCTS] Invalid product ID:', newButton.dataset.productId);
                showToast('Ошибка: неверный ID товара', 'error');
                return;
            }
            
            switch (action) {
                case 'edit':
                    editProduct(productId);
                    break;
                case 'toggle':
                    const currentStatus = newButton.dataset.currentStatus === 'true';
                    toggleProductStatus(productId, currentStatus);
                    break;
                case 'delete':
                    deleteProduct(productId);
                    break;
            }
        });
    });
}

async function toggleProductStatus(productId, currentStatus) {
    // Проверяем, что ID валидный
    if (!productId || isNaN(productId)) {
        console.error('[TOGGLE] Invalid product ID:', productId);
        showToast('Ошибка: неверный ID товара', 'error');
        return;
    }
    
    try {
        const newStatus = !currentStatus;
        console.log('[TOGGLE] Toggling product status:', productId, 'to', newStatus);
        await api.request(`/products/${productId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ is_active: newStatus })
        });
        
        showToast(newStatus ? 'Товар активирован' : 'Товар деактивирован', 'success');
        await loadMyProducts();
        await loadMyShop();
    } catch (error) {
        console.error('[TOGGLE] Error toggling product status:', error);
        showToast('Ошибка изменения статуса', 'error');
    }
}

// Экспортируем функцию для использования в HTML
window.toggleProductStatus = toggleProductStatus;

async function deleteProduct(productId) {
    // Проверяем, что ID валидный
    if (!productId || isNaN(productId)) {
        console.error('[DELETE] Invalid product ID:', productId);
        showToast('Ошибка: неверный ID товара', 'error');
        return;
    }
    
    if (!confirm('Удалить этот товар?\n\nЭто действие нельзя отменить. Товар будет полностью удален из базы данных.')) return;
    
    try {
        console.log('[DELETE] Deleting product:', productId);
        await api.request(`/products/${productId}`, { method: 'DELETE' });
        showToast('Товар удалён', 'success');
        // Обновляем список товаров и статистику магазина
        await loadMyProducts();
        // Перезагружаем данные магазина, чтобы обновился счетчик товаров
        await loadMyShop();
    } catch (error) {
        console.error('[DELETE] Error deleting product:', error);
        showToast('Ошибка удаления: ' + (error.message || 'Неизвестная ошибка'), 'error');
    }
}

// Экспортируем функцию для использования в HTML
window.deleteProduct = deleteProduct;

// ==================== Shop Orders ====================

let shopOrdersState = {
    orders: [],
    currentStatus: '',
    loading: false
};

async function loadShopOrders(status = '') {
    if (!state.myShop) {
        showToast('Магазин не найден', 'error');
        return;
    }
    
    shopOrdersState.currentStatus = status;
    shopOrdersState.loading = true;
    
    const ordersList = document.getElementById('shopOrdersList');
    const ordersEmpty = document.getElementById('shopOrdersEmpty');
    
    try {
        const orders = await api.getShopOrders(state.myShop.id, {
            status: status || undefined,
            limit: 50
        });
        
        shopOrdersState.orders = orders;
        
        if (orders.length === 0) {
            if (ordersList) ordersList.innerHTML = '';
            if (ordersEmpty) ordersEmpty.hidden = false;
        } else {
            if (ordersEmpty) ordersEmpty.hidden = true;
            if (ordersList) {
                ordersList.innerHTML = orders.map(order => renderShopOrderCard(order)).join('');
                
                // Добавляем обработчики для изменения статуса
                ordersList.querySelectorAll('.order-status-select').forEach(select => {
                    select.addEventListener('change', (e) => {
                        const orderId = parseInt(e.target.dataset.orderId);
                        const newStatus = e.target.value;
                        updateOrderStatus(orderId, newStatus);
                    });
                });
            }
        }
        
        // Обновляем активные вкладки фильтров
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.status === status);
        });
        
        // Инициализируем обработчики фильтров после первой загрузки
        if (!document.querySelector('.filter-tab')?.hasAttribute('data-listener')) {
            initOrderFilters();
            document.querySelectorAll('.filter-tab').forEach(tab => {
                tab.setAttribute('data-listener', 'true');
            });
        }
    } catch (error) {
        console.error('Error loading shop orders:', error);
        showToast('Ошибка загрузки заказов', 'error');
        if (ordersEmpty) ordersEmpty.hidden = false;
    } finally {
        shopOrdersState.loading = false;
    }
}

// Функция для форматирования даты доставки
function formatDeliveryDate(dateString) {
    if (!dateString) return 'Не указана';
    try {
        // Парсим дату (может быть в формате YYYY-MM-DD или ISO)
        if (typeof dateString === 'string' && dateString.includes('-')) {
            const parts = dateString.split('-');
            if (parts.length === 3) {
                // Формат YYYY-MM-DD
                const date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                return date.toLocaleDateString('ru-RU', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                });
            }
        }
        // Пробуем распарсить как ISO дату
        const date = new Date(dateString);
        if (!isNaN(date.getTime())) {
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }
        return dateString;
    } catch (e) {
        console.error('Error formatting delivery date:', e, dateString);
        return dateString || 'Не указана';
    }
}

function renderShopOrderCard(order) {
    const statusLabels = {
        'pending': 'Ожидает',
        'processing': 'В обработке',
        'delivered': 'Доставлен',
        'cancelled': 'Отменён'
    };
    
    const statusColors = {
        'pending': '#FFA726',
        'processing': '#42A5F5',
        'delivered': '#66BB6A',
        'cancelled': '#EF5350'
    };
    
    const statusLabel = statusLabels[order.status] || order.status;
    const statusColor = statusColors[order.status] || '#757575';
    
    const orderDate = new Date(order.created_at);
    const dateStr = orderDate.toLocaleDateString('ru-RU', {
        day: 'numeric',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
    
    const itemsList = order.items.map(item => {
        const itemPrice = item.discount_price || item.price;
        return `
            <div class="order-item-mini">
                <span class="order-item-name">${item.product_name || 'Товар'} × ${item.quantity}</span>
                <span class="order-item-price">${formatPrice(parseFloat(itemPrice) * item.quantity)}</span>
            </div>
        `;
    }).join('');
    
    return `
        <div class="shop-order-card" data-order-id="${order.id}">
            <div class="order-card-header">
                <div class="order-number">${order.order_number}</div>
                <div class="order-date">${dateStr}</div>
            </div>
            
            <div class="order-customer-info">
                <div class="info-row">
                    <span class="info-label">Клиент:</span>
                    <span>${order.recipient_name || 'Не указано'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Телефон:</span>
                    <span>${order.recipient_phone || 'Не указан'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Адрес:</span>
                    <span>${order.delivery_address || 'Не указан'}</span>
                </div>
                ${order.delivery_date ? `
                <div class="info-row">
                    <span class="info-label">Дата доставки:</span>
                    <span>${formatDeliveryDate(order.delivery_date)}</span>
                </div>
                ` : ''}
                ${order.delivery_time_slot ? `
                <div class="info-row">
                    <span class="info-label">Время доставки:</span>
                    <span>${order.delivery_time_slot}</span>
                </div>
                ` : ''}
            </div>
            
            <div class="order-items-list">
                ${itemsList}
            </div>
            
            <div class="order-card-footer">
                <div class="order-total">
                    <span>Итого:</span>
                    <span class="total-amount">${formatPrice(order.total_amount)}</span>
                </div>
                <div class="order-status-control">
                    <select class="order-status-select" data-order-id="${order.id}" style="border-color: ${statusColor}">
                        <option value="pending" ${order.status === 'pending' ? 'selected' : ''}>Ожидает</option>
                        <option value="processing" ${order.status === 'processing' ? 'selected' : ''}>В обработке</option>
                        <option value="delivered" ${order.status === 'delivered' ? 'selected' : ''}>Доставлен</option>
                        <option value="cancelled" ${order.status === 'cancelled' ? 'selected' : ''}>Отменён</option>
                    </select>
                </div>
            </div>
            
            ${order.comment ? `<div class="order-comment"><strong>Комментарий:</strong> ${order.comment}</div>` : ''}
        </div>
    `;
}

async function updateOrderStatus(orderId, newStatus) {
    try {
        await api.updateOrderStatus(orderId, newStatus);
        showToast('Статус заказа обновлён', 'success');
        await loadShopOrders(shopOrdersState.currentStatus);
    } catch (error) {
        console.error('Error updating order status:', error);
        showToast('Ошибка обновления статуса', 'error');
        // Перезагружаем заказы, чтобы вернуть предыдущий статус
        await loadShopOrders(shopOrdersState.currentStatus);
    }
}

// ==================== User Orders ====================

async function loadUserOrders(status = '') {
    const ordersList = elements.userOrdersList;
    const ordersEmpty = elements.userOrdersEmpty;
    
    if (!ordersList || !ordersEmpty) {
        console.error('[USER ORDERS] Elements not found');
        return;
    }
    
    try {
        const orders = await api.getOrders({
            status: status || undefined,
            limit: 50
        });
        
        if (orders.length === 0) {
            ordersList.innerHTML = '';
            ordersEmpty.hidden = false;
        } else {
            ordersEmpty.hidden = true;
            ordersList.innerHTML = orders.map(order => renderUserOrderCard(order)).join('');
        }
        
        // Обновляем активные вкладки фильтров
        const filterTabs = document.querySelectorAll('#myOrdersPage .filter-tab');
        filterTabs.forEach(tab => {
            tab.classList.toggle('active', tab.dataset.status === status);
        });
        
        // Инициализируем обработчики фильтров
        filterTabs.forEach(tab => {
            const newTab = tab.cloneNode(true);
            tab.parentNode.replaceChild(newTab, tab);
            
            newTab.addEventListener('click', () => {
                const filterStatus = newTab.dataset.status;
                loadUserOrders(filterStatus);
            });
        });
    } catch (error) {
        console.error('[USER ORDERS] Error loading orders:', error);
        showToast('Ошибка загрузки заказов', 'error');
        if (ordersEmpty) ordersEmpty.hidden = false;
    }
}

function renderUserOrderCard(order) {
    const statusLabels = {
        'pending': 'Ожидает',
        'processing': 'В обработке',
        'delivered': 'Доставлен',
        'cancelled': 'Отменен'
    };
    
    const statusColors = {
        'pending': '#FFA726',
        'processing': '#42A5F5',
        'delivered': '#66BB6A',
        'cancelled': '#EF5350'
    };
    
    const statusLabel = statusLabels[order.status] || order.status;
    const statusColor = statusColors[order.status] || '#9CA3AF';
    
    const itemsHtml = order.items?.map(item => {
        const imageUrl = item.product_image_url ? getMediaUrl(item.product_image_url) : '';
        return `
            <div class="order-item">
                ${imageUrl ? `<img src="${imageUrl}" alt="${item.product_name || 'Товар'}" class="order-item-image">` : '<div class="order-item-image-placeholder">📦</div>'}
                <div class="order-item-info">
                    <div class="order-item-name">${item.product_name || 'Товар'}</div>
                    <div class="order-item-details">
                        <span>${item.quantity} шт.</span>
                        <span>×</span>
                        <span>${formatPrice(item.price)}</span>
                    </div>
                </div>
                <div class="order-item-total">${formatPrice(item.quantity * item.price)}</div>
            </div>
        `;
    }).join('') || '';
    
    return `
        <div class="user-order-card">
            <div class="order-header">
                <div class="order-info">
                    <div class="order-number">Заказ #${order.order_number || order.id}</div>
                    <div class="order-date">${formatOrderDate(order.created_at)}</div>
                </div>
                <div class="order-status-badge" style="background-color: ${statusColor}20; color: ${statusColor};">
                    ${statusLabel}
                </div>
            </div>
            <div class="order-shop">
                <span class="order-shop-label">Магазин:</span>
                <span class="order-shop-name">${order.shop_name || 'Неизвестный магазин'}</span>
            </div>
            <div class="order-items">
                ${itemsHtml}
            </div>
            ${order.delivery_address ? `
            <div class="order-delivery">
                <span class="order-delivery-label">Адрес доставки:</span>
                <span class="order-delivery-address">${order.delivery_address}</span>
            </div>
            ` : ''}
            ${order.delivery_date ? `
            <div class="order-delivery-info">
                <span class="order-delivery-label">Дата доставки:</span>
                <span>${formatDeliveryDate(order.delivery_date)}</span>
            </div>
            ` : ''}
            ${order.delivery_time_slot ? `
            <div class="order-delivery-info">
                <span class="order-delivery-label">Время доставки:</span>
                <span>${order.delivery_time_slot}</span>
            </div>
            ` : ''}
            <div class="order-footer">
                <div class="order-total">
                    <span class="order-total-label">Итого:</span>
                    <span class="order-total-value">${formatPrice(order.total_amount)}</span>
                </div>
            </div>
        </div>
    `;
}

function formatOrderDate(dateString) {
    if (!dateString) return '';
    try {
        const date = new Date(dateString);
        return date.toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    } catch (e) {
        return dateString;
    }
}

// Инициализация обработчиков фильтров заказов
function initOrderFilters() {
    document.querySelectorAll('.filter-tab').forEach(tab => {
        // Удаляем старые обработчики
        const newTab = tab.cloneNode(true);
        tab.parentNode.replaceChild(newTab, tab);
        
        // Добавляем новый обработчик
        newTab.addEventListener('click', () => {
            const status = newTab.dataset.status;
            loadShopOrders(status);
        });
    });
}

// ==================== Shop Statistics Dashboard ====================

// Глобальная переменная для хранения экземпляров графиков Chart.js
let statisticsCharts = {
    revenue: null,
    orders: null,
    status: null,
    topProducts: null
};

async function loadShopStatistics() {
    if (!state.myShop) {
        showToast('Магазин не найден', 'error');
        return;
    }
    
    const loadingEl = document.getElementById('statisticsLoading');
    const emptyEl = document.getElementById('statisticsEmpty');
    const contentEl = document.querySelector('#shopStatisticsPage .page-content > .statistics-cards');
    
    if (loadingEl) loadingEl.hidden = false;
    if (emptyEl) emptyEl.hidden = true;
    if (contentEl) contentEl.style.opacity = '0.5';
    
    try {
        const startDate = document.getElementById('statisticsStartDate')?.value;
        const endDate = document.getElementById('statisticsEndDate')?.value;
        
        // Проверка доступности метода
        if (typeof api === 'undefined' || !api || typeof api.getShopStatistics !== 'function') {
            console.error('[STATISTICS] API or method not available');
            console.error('[STATISTICS] api:', api);
            if (api) {
                console.error('[STATISTICS] Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(api)).filter(m => typeof api[m] === 'function'));
            }
            throw new Error('API метод getShopStatistics недоступен. Обновите страницу (Ctrl+F5)');
        }
        
        const stats = await api.getShopStatistics(startDate, endDate);
        
        // Обновляем основные метрики
        document.getElementById('statTotalOrders').textContent = stats.total_orders || 0;
        document.getElementById('statTotalRevenue').textContent = formatPrice(stats.total_revenue || 0);
        document.getElementById('statAvgOrderValue').textContent = formatPrice(stats.average_order_value || 0);
        
        // Отрисовываем графики
        renderStatisticsCharts(stats);
        
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
        
        if (stats.total_orders === 0) {
            if (emptyEl) emptyEl.hidden = false;
        } else {
            if (emptyEl) emptyEl.hidden = true;
        }
    } catch (error) {
        console.error('[STATISTICS] Error loading statistics:', error);
        showToast('Ошибка загрузки статистики', 'error');
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
    }
}

function renderStatisticsCharts(stats) {
    renderRevenueChart(stats.revenue_by_day);
    renderOrdersChart(stats.orders_by_day);
    renderStatusChart(stats.orders_by_status_count);
    renderTopProductsChart(stats.top_products);
}

function renderRevenueChart(data) {
    const ctx = document.getElementById('revenueChart');
    if (!ctx) return;
    
    if (statisticsCharts.revenue) {
        statisticsCharts.revenue.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.revenue);
    
    statisticsCharts.revenue = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Выручка, ₽',
                data: values,
                borderColor: '#FF8C69',
                backgroundColor: 'rgba(255, 140, 105, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value.toLocaleString('ru-RU') + ' ₽';
                        }
                    }
                }
            }
        }
    });
}

function renderOrdersChart(data) {
    const ctx = document.getElementById('ordersChart');
    if (!ctx) return;
    
    if (statisticsCharts.orders) {
        statisticsCharts.orders.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.count);
    
    statisticsCharts.orders = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Заказов',
                data: values,
                backgroundColor: '#FFB886',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }
                }
            }
        }
    });
}

function renderStatusChart(data) {
    const ctx = document.getElementById('statusChart');
    if (!ctx) return;
    
    if (statisticsCharts.status) {
        statisticsCharts.status.destroy();
    }
    
    const statusLabels = {
        'pending': 'Ожидают',
        'processing': 'В обработке',
        'delivered': 'Доставлены',
        'cancelled': 'Отменены'
    };
    
    const labels = Object.keys(data).map(key => statusLabels[key] || key);
    const values = Object.values(data);
    const colors = ['#FFA726', '#42A5F5', '#66BB6A', '#EF5350'];
    
    statisticsCharts.status = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: colors.slice(0, values.length)
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { position: 'bottom' } }
        }
    });
}

function renderTopProductsChart(data) {
    const ctx = document.getElementById('topProductsChart');
    if (!ctx) return;
    
    if (statisticsCharts.topProducts) {
        statisticsCharts.topProducts.destroy();
    }
    
    if (!data || data.length === 0) {
        const canvas = ctx.getContext('2d');
        if (canvas) canvas.clearRect(0, 0, ctx.width || 400, ctx.height || 300);
        return;
    }
    
    const top5 = data.slice(0, 5);
    const labels = top5.map(item => {
        const name = item.product_name || 'Неизвестный товар';
        return name.length > 20 ? name.substring(0, 20) + '...' : name;
    });
    const values = top5.map(item => item.total_quantity);
    
    statisticsCharts.topProducts = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Количество продаж',
                data: values,
                backgroundColor: '#FF8C69',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: { legend: { display: false } },
            scales: {
                x: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }
                }
            }
        }
    });
}

function initStatisticsDashboard() {
    document.getElementById('loadStatisticsBtn')?.addEventListener('click', () => {
        loadShopStatistics();
    });
    
    document.querySelectorAll('.period-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const period = btn.dataset.period;
            const endDate = new Date();
            const startDate = new Date();
            
            if (period === '7') {
                startDate.setDate(endDate.getDate() - 7);
            } else if (period === '30') {
                startDate.setDate(endDate.getDate() - 30);
            } else if (period === '90') {
                startDate.setDate(endDate.getDate() - 90);
            } else if (period === 'month') {
                startDate.setDate(1);
            }
            
            const startInput = document.getElementById('statisticsStartDate');
            const endInput = document.getElementById('statisticsEndDate');
            
            if (startInput) {
                startInput.value = startDate.toISOString().split('T')[0];
            }
            if (endInput) {
                endInput.value = endDate.toISOString().split('T')[0];
            }
            
            loadShopStatistics();
        });
    });
    
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - 30);
    
    const startInput = document.getElementById('statisticsStartDate');
    const endInput = document.getElementById('statisticsEndDate');
    
    if (startInput && !startInput.value) {
        startInput.value = startDate.toISOString().split('T')[0];
    }
    if (endInput && !endInput.value) {
        endInput.value = endDate.toISOString().split('T')[0];
    }
}

// ==================== Shop Reviews Page ====================

async function loadShopReviewsPage() {
    if (!state.myShop) {
        showToast('Магазин не найден', 'error');
        return;
    }
    
    const reviewsList = document.getElementById('shopReviewsListFull');
    const reviewsEmpty = document.getElementById('shopReviewsEmptyFull');
    const statsCard = document.getElementById('reviewsStatsCard');
    
    try {
        // Загружаем статистику отзывов
        const stats = await api.request(`/reviews/shop/${state.myShop.id}/stats`);
        renderReviewsStats(stats);
        
        // Загружаем отзывы
        const reviews = await api.getShopReviews(state.myShop.id, { limit: 100 });
        
        if (reviews.length === 0) {
            if (reviewsList) reviewsList.innerHTML = '';
            if (reviewsEmpty) reviewsEmpty.hidden = false;
        } else {
            if (reviewsEmpty) reviewsEmpty.hidden = true;
            if (reviewsList) {
                reviewsList.innerHTML = reviews.map(review => renderShopReviewCard(review)).join('');
            }
        }
    } catch (error) {
        console.error('Error loading shop reviews:', error);
        showToast('Ошибка загрузки отзывов', 'error');
        if (reviewsEmpty) reviewsEmpty.hidden = false;
    }
}

function renderReviewsStats(stats) {
    const averageRating = parseFloat(stats.average || 0).toFixed(1);
    const totalReviews = stats.total || 0;
    
    const averageRatingEl = document.getElementById('reviewsAverageRating');
    const starsDisplayEl = document.getElementById('reviewsStarsDisplay');
    const totalCountEl = document.getElementById('reviewsTotalCount');
    const breakdownEl = document.getElementById('reviewsRatingBreakdown');
    
    if (averageRatingEl) averageRatingEl.textContent = averageRating;
    if (totalCountEl) totalCountEl.textContent = `${totalReviews} ${totalReviews === 1 ? 'отзыв' : totalReviews < 5 ? 'отзыва' : 'отзывов'}`;
    
    if (starsDisplayEl) {
        const fullStars = Math.round(parseFloat(averageRating));
        starsDisplayEl.innerHTML = '⭐'.repeat(fullStars) + '☆'.repeat(5 - fullStars);
    }
    
    if (breakdownEl && totalReviews > 0) {
        breakdownEl.innerHTML = `
            <div class="rating-bar" data-rating="5">
                <span class="rating-label">5 ⭐</span>
                <div class="rating-bar-container">
                    <div class="rating-bar-fill" style="width: ${((stats.five_star || 0) / totalReviews * 100).toFixed(0)}%"></div>
                </div>
                <span class="rating-count">${stats.five_star || 0}</span>
            </div>
            <div class="rating-bar" data-rating="4">
                <span class="rating-label">4 ⭐</span>
                <div class="rating-bar-container">
                    <div class="rating-bar-fill" style="width: ${((stats.four_star || 0) / totalReviews * 100).toFixed(0)}%"></div>
                </div>
                <span class="rating-count">${stats.four_star || 0}</span>
            </div>
            <div class="rating-bar" data-rating="3">
                <span class="rating-label">3 ⭐</span>
                <div class="rating-bar-container">
                    <div class="rating-bar-fill" style="width: ${((stats.three_star || 0) / totalReviews * 100).toFixed(0)}%"></div>
                </div>
                <span class="rating-count">${stats.three_star || 0}</span>
            </div>
            <div class="rating-bar" data-rating="2">
                <span class="rating-label">2 ⭐</span>
                <div class="rating-bar-container">
                    <div class="rating-bar-fill" style="width: ${((stats.two_star || 0) / totalReviews * 100).toFixed(0)}%"></div>
                </div>
                <span class="rating-count">${stats.two_star || 0}</span>
            </div>
            <div class="rating-bar" data-rating="1">
                <span class="rating-label">1 ⭐</span>
                <div class="rating-bar-container">
                    <div class="rating-bar-fill" style="width: ${((stats.one_star || 0) / totalReviews * 100).toFixed(0)}%"></div>
                </div>
                <span class="rating-count">${stats.one_star || 0}</span>
            </div>
        `;
    } else if (breakdownEl) {
        breakdownEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Нет данных</p>';
    }
}

function renderShopReviewCard(review) {
    const reviewDate = new Date(review.created_at);
    const dateStr = reviewDate.toLocaleDateString('ru-RU', {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
    });
    
    return `
        <div class="shop-review-card-full">
            <div class="review-header">
                <div class="review-author">
                    <span class="author-avatar">${review.user_name ? review.user_name.charAt(0).toUpperCase() : 'П'}</span>
                    <div class="author-info">
                        <div class="author-name">${review.user_name || 'Пользователь'}</div>
                        <div class="review-date">${dateStr}</div>
                    </div>
                </div>
                <div class="review-rating-display">
                    ${'⭐'.repeat(review.rating)}${'☆'.repeat(5 - review.rating)}
                </div>
            </div>
            ${review.comment ? `<div class="review-comment">${review.comment}</div>` : ''}
            ${review.is_verified ? '<div class="review-verified">✓ Проверенная покупка</div>' : ''}
        </div>
    `;
}

// Эта функция удалена, так как правильная функция editProduct определена выше
// function editProduct(productId) {
//     showToast('Редактирование будет добавлено позже', 'info');
// }

// ============= Subscription Management =============

async function loadSubscriptionManagement() {
    try {
        // Загружаем текущую подписку
        const subscription = await api.getMySubscription();
        
        if (subscription) {
            renderCurrentSubscription(subscription);
            elements.subscriptionLimitsCard.hidden = false;
            
            // Загружаем статистику использования
            await loadSubscriptionUsage();
        } else {
            // Нет активной подписки
            renderNoSubscription();
            elements.subscriptionLimitsCard.hidden = true;
        }
        
        // Загружаем историю
        await loadSubscriptionHistory();
        
    } catch (error) {
        console.error('Error loading subscription management:', error);
        showToast('Ошибка загрузки данных подписки', 'error');
    }
}

async function loadSubscriptionUsage() {
    try {
        const usage = await api.getSubscriptionUsage();
        
        // Обновляем использование товаров
        const productsPercent = usage.max_products > 0 
            ? Math.min(100, (usage.products_count / usage.max_products) * 100) 
            : 0;
        elements.productsUsage.textContent = `${usage.products_count} / ${usage.max_products}`;
        elements.productsLimitFill.style.width = `${productsPercent}%`;
        
        // Обновляем использование промо
        const promotionsPercent = usage.max_promotions > 0 
            ? Math.min(100, (usage.promotions_count / usage.max_promotions) * 100) 
            : 0;
        elements.promotionsUsage.textContent = `${usage.promotions_count} / ${usage.max_promotions}`;
        elements.promotionsLimitFill.style.width = `${promotionsPercent}%`;
        
    } catch (error) {
        console.error('Error loading subscription usage:', error);
    }
}

function renderCurrentSubscription(subscription) {
    const startDate = new Date(subscription.start_date);
    const endDate = new Date(subscription.end_date);
    const now = new Date();
    const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
    const remainingDays = Math.max(0, Math.ceil((endDate - now) / (1000 * 60 * 60 * 24)));
    const progress = totalDays > 0 ? ((totalDays - remainingDays) / totalDays * 100) : 0;
    
    // Статус
    const statusText = remainingDays > 0 ? 'Активна' : 'Истекла';
    const statusClass = remainingDays > 0 ? 'active' : 'expired';
    elements.subscriptionStatusBadge.textContent = statusText;
    elements.subscriptionStatusBadge.className = `subscription-status-badge ${statusClass}`;
    
    // План
    elements.managementPlanName.textContent = subscription.plan_name || 'План';
    
    // Даты
    elements.subscriptionStartDate.textContent = formatDateObject(startDate);
    elements.subscriptionEndDate.textContent = formatDateObject(endDate);
    elements.subscriptionDaysRemaining.textContent = `${remainingDays} ${pluralize(remainingDays, 'день', 'дня', 'дней')}`;
    
    // Прогресс
    elements.subscriptionProgressFill.style.width = `${Math.min(100, progress)}%`;
    
    // Кнопки
    elements.extendSubscriptionBtn.hidden = remainingDays <= 0;
    elements.changePlanBtn.hidden = false;
}

function renderNoSubscription() {
    elements.subscriptionStatusBadge.textContent = 'Нет подписки';
    elements.subscriptionStatusBadge.className = 'subscription-status-badge inactive';
    elements.managementPlanName.textContent = '—';
    elements.subscriptionStartDate.textContent = '—';
    elements.subscriptionEndDate.textContent = '—';
    elements.subscriptionDaysRemaining.textContent = '0 дней';
    elements.subscriptionProgressFill.style.width = '0%';
    elements.extendSubscriptionBtn.hidden = true;
    elements.changePlanBtn.textContent = 'Оформить подписку';
}

async function loadSubscriptionHistory() {
    try {
        const history = await api.getSubscriptionHistory();
        
        if (history.length === 0) {
            elements.subscriptionHistoryList.innerHTML = '';
            elements.subscriptionHistoryEmpty.hidden = false;
            return;
        }
        
        elements.subscriptionHistoryEmpty.hidden = true;
        
        // Показываем только последние 3 по умолчанию
        const showAll = state.showAllSubscriptionHistory || false;
        const displayHistory = showAll ? history : history.slice(0, 3);
        
        elements.subscriptionHistoryList.innerHTML = displayHistory.map(sub => {
            const startDate = new Date(sub.start_date);
            const endDate = new Date(sub.end_date);
            const now = new Date();
            const isActive = sub.is_active && endDate > now;
            const isExpired = endDate < now;
            
            return `
                <div class="history-item ${isActive ? 'active' : isExpired ? 'expired' : ''}">
                    <div class="history-item-header">
                        <span class="history-plan-name">${sub.plan_name}</span>
                        <span class="history-status ${isActive ? 'active' : isExpired ? 'expired' : 'inactive'}">
                            ${isActive ? 'Активна' : isExpired ? 'Истекла' : 'Неактивна'}
                        </span>
                    </div>
                    <div class="history-item-dates">
                        <span>${formatDateObject(startDate)} — ${formatDateObject(endDate)}</span>
                    </div>
                    <div class="history-item-payment">
                        <span>ID: ${sub.payment_id || 'N/A'}</span>
                    </div>
                </div>
            `;
        }).join('');
        
        // Кнопка "Показать все"
        if (history.length > 3) {
            elements.showAllHistoryBtn.hidden = false;
            elements.showAllHistoryBtn.textContent = showAll ? 'Скрыть' : `Показать все (${history.length})`;
        } else {
            elements.showAllHistoryBtn.hidden = true;
        }
        
    } catch (error) {
        console.error('Error loading subscription history:', error);
        elements.subscriptionHistoryList.innerHTML = '';
        elements.subscriptionHistoryEmpty.hidden = false;
    }
}

// Функция formatDate для форматирования Date объектов (отличается от formatDate из utils.js, которая принимает строку)
function formatDateObject(date) {
    if (!date) return '';
    return new Intl.DateTimeFormat('ru-RU', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    }).format(date);
}

// Функция pluralize уже импортирована из modules/utils.js

// Обработчики для управления подпиской
function initSubscriptionManagementHandlers() {
    // Продлить подписку
    elements.extendSubscriptionBtn?.addEventListener('click', async () => {
        navigateTo('subscription');
        openSubscriptionModal();
    });
    
    // Изменить план
    elements.changePlanBtn?.addEventListener('click', () => {
        navigateTo('subscription');
        openSubscriptionModal();
    });
    
    // Показать всю историю
    elements.showAllHistoryBtn?.addEventListener('click', () => {
        state.showAllSubscriptionHistory = !state.showAllSubscriptionHistory;
        loadSubscriptionHistory();
    });
}

// Делаем функции глобальными для onclick
window.openProductPage = openProductPage;
window.closeSearch = closeSearch;
window.updateCartQuantity = updateCartQuantity;
window.removeFromCart = removeFromCart;
window.subscribeToPlan = subscribeToPlan;
window.requestSubscribeToPlan = requestSubscribeToPlan;
// window.editProduct и window.deleteProduct уже определены выше
// window.editProduct = editProduct;
// window.deleteProduct = deleteProduct;

// ==================== Settings ====================

// Загрузка настроек из localStorage
function loadSettings() {
    try {
        const settings = JSON.parse(localStorage.getItem('appSettings') || '{}');
        
        if (elements.notifyOrders) elements.notifyOrders.checked = settings.notifyOrders !== false;
        if (elements.notifyMessages) elements.notifyMessages.checked = settings.notifyMessages !== false;
        if (elements.notifyPromotions) elements.notifyPromotions.checked = settings.notifyPromotions === true;
        if (elements.autoPlayVideos) elements.autoPlayVideos.checked = settings.autoPlayVideos !== false;
        if (elements.showImagesOnly) elements.showImagesOnly.checked = settings.showImagesOnly === true;
        if (elements.appVersion) elements.appVersion.textContent = '1.0.0';
        
        console.log('[SETTINGS] Settings loaded:', settings);
    } catch (error) {
        console.error('[SETTINGS] Error loading settings:', error);
    }
}

// Сохранение настроек в localStorage
function saveSettings() {
    try {
        const settings = {
            notifyOrders: elements.notifyOrders?.checked ?? true,
            notifyMessages: elements.notifyMessages?.checked ?? true,
            notifyPromotions: elements.notifyPromotions?.checked ?? false,
            autoPlayVideos: elements.autoPlayVideos?.checked ?? true,
            showImagesOnly: elements.showImagesOnly?.checked ?? false
        };
        
        localStorage.setItem('appSettings', JSON.stringify(settings));
        console.log('[SETTINGS] Settings saved:', settings);
        
        showToast('✅ Настройки сохранены', 'success');
        
        // Применяем настройки к приложению
        applySettings(settings);
    } catch (error) {
        console.error('[SETTINGS] Error saving settings:', error);
        showToast('Ошибка сохранения настроек', 'error');
    }
}

// Применение настроек к приложению
function applySettings(settings) {
    // Применяем настройку автопроигрывания видео
    if (settings.autoPlayVideos === false) {
        // Останавливаем все видео в каталоге
        document.querySelectorAll('.products-grid video').forEach(video => {
            video.pause();
        });
    }
    
    // Применяем настройку показа только изображений
    if (settings.showImagesOnly === true) {
        // Скрываем видео в каталоге
        document.querySelectorAll('.products-grid video').forEach(video => {
            video.style.display = 'none';
        });
    } else {
        // Показываем видео
        document.querySelectorAll('.products-grid video').forEach(video => {
            video.style.display = '';
        });
    }
}

// Очистка кэша
function clearCache() {
    if (!confirm('Вы уверены, что хотите очистить кэш? Это может замедлить загрузку изображений.')) {
        return;
    }
    
    try {
        // Очищаем localStorage (кроме настроек и важных данных)
        const settings = localStorage.getItem('appSettings');
        const favorites = localStorage.getItem('favorites');
        
        localStorage.clear();
        
        // Восстанавливаем важные данные
        if (settings) localStorage.setItem('appSettings', settings);
        if (favorites) localStorage.setItem('favorites', favorites);
        
        // Очищаем все blob URL
        document.querySelectorAll('video[src^="blob:"], img[src^="blob:"]').forEach(el => {
            try {
                URL.revokeObjectURL(el.src);
            } catch (e) {
                // Игнорируем ошибки
            }
        });
        
        // Перезагружаем страницу для применения изменений
        showToast('✅ Кэш очищен. Страница будет перезагружена', 'success');
        setTimeout(() => {
            window.location.reload();
        }, 1000);
    } catch (error) {
        console.error('[SETTINGS] Error clearing cache:', error);
        showToast('Ошибка очистки кэша', 'error');
    }
}

// Загружаем настройки при инициализации
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        try {
            const settings = JSON.parse(localStorage.getItem('appSettings') || '{}');
            applySettings(settings);
        } catch (error) {
            console.error('[SETTINGS] Error applying settings on load:', error);
        }
    });
}

// ==================== Shop Statistics Dashboard ====================

async function loadShopStatistics() {
    if (!state.myShop) {
        showToast('Магазин не найден', 'error');
        return;
    }
    
    const loadingEl = document.getElementById('statisticsLoading');
    const emptyEl = document.getElementById('statisticsEmpty');
    const contentEl = document.querySelector('#shopStatisticsPage .page-content > .statistics-cards');
    
    if (loadingEl) loadingEl.hidden = false;
    if (emptyEl) emptyEl.hidden = true;
    if (contentEl) contentEl.style.opacity = '0.5';
    
    try {
        const startDate = document.getElementById('statisticsStartDate')?.value;
        const endDate = document.getElementById('statisticsEndDate')?.value;
        
        // Проверка доступности метода
        if (typeof api === 'undefined' || !api || typeof api.getShopStatistics !== 'function') {
            console.error('[STATISTICS] API or method not available');
            console.error('[STATISTICS] api:', api);
            if (api) {
                console.error('[STATISTICS] Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(api)).filter(m => typeof api[m] === 'function'));
            }
            throw new Error('API метод getShopStatistics недоступен. Обновите страницу (Ctrl+F5)');
        }
        
        const stats = await api.getShopStatistics(startDate, endDate);
        
        // Обновляем основные метрики
        document.getElementById('statTotalOrders').textContent = stats.total_orders || 0;
        document.getElementById('statTotalRevenue').textContent = formatPrice(stats.total_revenue || 0);
        document.getElementById('statAvgOrderValue').textContent = formatPrice(stats.average_order_value || 0);
        
        // Отрисовываем графики
        renderStatisticsCharts(stats);
        
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
        
        if (stats.total_orders === 0) {
            if (emptyEl) emptyEl.hidden = false;
        } else {
            if (emptyEl) emptyEl.hidden = true;
        }
    } catch (error) {
        console.error('[STATISTICS] Error loading statistics:', error);
        showToast('Ошибка загрузки статистики', 'error');
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
    }
}

function renderStatisticsCharts(stats) {
    // График выручки по дням
    renderRevenueChart(stats.revenue_by_day);
    
    // График заказов по дням
    renderOrdersChart(stats.orders_by_day);
    
    // График заказов по статусам
    renderStatusChart(stats.orders_by_status_count);
    
    // График топ товаров
    renderTopProductsChart(stats.top_products);
}

function renderRevenueChart(data) {
    const ctx = document.getElementById('revenueChart');
    if (!ctx) return;
    
    // Уничтожаем предыдущий график
    if (statisticsCharts.revenue) {
        statisticsCharts.revenue.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.revenue);
    
    statisticsCharts.revenue = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Выручка, ₽',
                data: values,
                borderColor: '#FF8C69',
                backgroundColor: 'rgba(255, 140, 105, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value.toLocaleString('ru-RU') + ' ₽';
                        }
                    }
                }
            }
        }
    });
}

function renderOrdersChart(data) {
    const ctx = document.getElementById('ordersChart');
    if (!ctx) return;
    
    if (statisticsCharts.orders) {
        statisticsCharts.orders.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.count);
    
    statisticsCharts.orders = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Заказов',
                data: values,
                backgroundColor: '#FFB886',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

function renderStatusChart(data) {
    const ctx = document.getElementById('statusChart');
    if (!ctx) return;
    
    if (statisticsCharts.status) {
        statisticsCharts.status.destroy();
    }
    
    const statusLabels = {
        'pending': 'Ожидают',
        'processing': 'В обработке',
        'delivered': 'Доставлены',
        'cancelled': 'Отменены'
    };
    
    const labels = Object.keys(data).map(key => statusLabels[key] || key);
    const values = Object.values(data);
    const colors = ['#FFA726', '#42A5F5', '#66BB6A', '#EF5350'];
    
    statisticsCharts.status = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: colors.slice(0, values.length)
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    });
}

function renderTopProductsChart(data) {
    const ctx = document.getElementById('topProductsChart');
    if (!ctx) return;
    
    if (statisticsCharts.topProducts) {
        statisticsCharts.topProducts.destroy();
    }
    
    if (!data || data.length === 0) {
        const canvas = ctx.getContext('2d');
        canvas.clearRect(0, 0, ctx.width, ctx.height);
        return;
    }
    
    // Берем первые 5 товаров
    const top5 = data.slice(0, 5);
    const labels = top5.map(item => {
        const name = item.product_name || 'Неизвестный товар';
        return name.length > 20 ? name.substring(0, 20) + '...' : name;
    });
    const values = top5.map(item => item.total_quantity);
    
    statisticsCharts.topProducts = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Количество продаж',
                data: values,
                backgroundColor: '#FF8C69',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

// Инициализация обработчиков для дашборда
function initStatisticsDashboard() {
    // Кнопка загрузки статистики
    document.getElementById('loadStatisticsBtn')?.addEventListener('click', () => {
        loadShopStatistics();
    });
    
    // Быстрый выбор периода
    document.querySelectorAll('.period-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const period = btn.dataset.period;
            const endDate = new Date();
            const startDate = new Date();
            
            if (period === '7') {
                startDate.setDate(endDate.getDate() - 7);
            } else if (period === '30') {
                startDate.setDate(endDate.getDate() - 30);
            } else if (period === '90') {
                startDate.setDate(endDate.getDate() - 90);
            } else if (period === 'month') {
                startDate.setDate(1);
            }
            
            const startInput = document.getElementById('statisticsStartDate');
            const endInput = document.getElementById('statisticsEndDate');
            
            if (startInput) {
                startInput.value = startDate.toISOString().split('T')[0];
            }
            if (endInput) {
                endInput.value = endDate.toISOString().split('T')[0];
            }
            
            loadShopStatistics();
        });
    });
    
    // Инициализация дат по умолчанию (последние 30 дней)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - 30);
    
    const startInput = document.getElementById('statisticsStartDate');
    const endInput = document.getElementById('statisticsEndDate');
    
    if (startInput && !startInput.value) {
        startInput.value = startDate.toISOString().split('T')[0];
    }
    if (endInput && !endInput.value) {
        endInput.value = endDate.toISOString().split('T')[0];
    }
}

// Экспортируем функции
window.saveSettings = saveSettings;
window.clearCache = clearCache;

// Тестовая функция для проверки кликов
window.testClick = function(elementId) {
    const el = document.getElementById(elementId);
    if (el) {
        console.log(`[TEST] Element ${elementId} found:`, el);
        el.style.border = '2px solid red';
        setTimeout(() => el.style.border = '', 1000);
    } else {
        console.error(`[TEST] Element ${elementId} NOT FOUND`);
    }
};

// Простой тест - если видите этот alert, скрипт загружен
console.log('🚀 app.js загружен!');

// Глобальная обработка ошибок
window.addEventListener('error', function(e) {
    console.error('❌ ГЛОБАЛЬНАЯ ОШИБКА:', e.error);
    console.error('Файл:', e.filename, 'Строка:', e.lineno);
    alert('ОШИБКА JavaScript: ' + e.message + '\nПроверьте консоль (F12)');
});

window.addEventListener('unhandledrejection', function(e) {
    console.error('❌ Необработанное отклонение промиса:', e.reason);
});

// Инициализация
console.log('🚀 [APP] Script loaded, waiting for DOM...');
console.log('📄 Document readyState:', document.readyState);

try {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            console.log('✅ [APP] DOMContentLoaded fired');
            try {
                init();
            } catch (error) {
                console.error('❌ Ошибка в init():', error);
                alert('Ошибка инициализации: ' + error.message);
            }
        });
    } else {
        // DOM уже загружен
// ==================== Shop Statistics Dashboard ====================

async function loadShopStatistics() {
    if (!state.myShop) {
        showToast('Магазин не найден', 'error');
        return;
    }
    
    const loadingEl = document.getElementById('statisticsLoading');
    const emptyEl = document.getElementById('statisticsEmpty');
    const contentEl = document.querySelector('#shopStatisticsPage .page-content > .statistics-cards');
    
    if (loadingEl) loadingEl.hidden = false;
    if (emptyEl) emptyEl.hidden = true;
    if (contentEl) contentEl.style.opacity = '0.5';
    
    try {
        const startDate = document.getElementById('statisticsStartDate')?.value;
        const endDate = document.getElementById('statisticsEndDate')?.value;
        
        // Проверка доступности метода
        if (typeof api === 'undefined' || !api || typeof api.getShopStatistics !== 'function') {
            console.error('[STATISTICS] API or method not available');
            console.error('[STATISTICS] api:', api);
            if (api) {
                console.error('[STATISTICS] Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(api)).filter(m => typeof api[m] === 'function'));
            }
            throw new Error('API метод getShopStatistics недоступен. Обновите страницу (Ctrl+F5)');
        }
        
        const stats = await api.getShopStatistics(startDate, endDate);
        
        // Обновляем основные метрики
        document.getElementById('statTotalOrders').textContent = stats.total_orders || 0;
        document.getElementById('statTotalRevenue').textContent = formatPrice(stats.total_revenue || 0);
        document.getElementById('statAvgOrderValue').textContent = formatPrice(stats.average_order_value || 0);
        
        // Отрисовываем графики
        renderStatisticsCharts(stats);
        
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
        
        if (stats.total_orders === 0) {
            if (emptyEl) emptyEl.hidden = false;
        } else {
            if (emptyEl) emptyEl.hidden = true;
        }
    } catch (error) {
        console.error('[STATISTICS] Error loading statistics:', error);
        showToast('Ошибка загрузки статистики', 'error');
        if (loadingEl) loadingEl.hidden = true;
        if (contentEl) contentEl.style.opacity = '1';
    }
}

function renderStatisticsCharts(stats) {
    // График выручки по дням
    renderRevenueChart(stats.revenue_by_day);
    
    // График заказов по дням
    renderOrdersChart(stats.orders_by_day);
    
    // График заказов по статусам
    renderStatusChart(stats.orders_by_status_count);
    
    // График топ товаров
    renderTopProductsChart(stats.top_products);
}

function renderRevenueChart(data) {
    const ctx = document.getElementById('revenueChart');
    if (!ctx) return;
    
    // Уничтожаем предыдущий график
    if (statisticsCharts.revenue) {
        statisticsCharts.revenue.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.revenue);
    
    statisticsCharts.revenue = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Выручка, ₽',
                data: values,
                borderColor: '#FF8C69',
                backgroundColor: 'rgba(255, 140, 105, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value.toLocaleString('ru-RU') + ' ₽';
                        }
                    }
                }
            }
        }
    });
}

function renderOrdersChart(data) {
    const ctx = document.getElementById('ordersChart');
    if (!ctx) return;
    
    if (statisticsCharts.orders) {
        statisticsCharts.orders.destroy();
    }
    
    const labels = data.map(item => {
        const date = new Date(item.date);
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' });
    });
    const values = data.map(item => item.count);
    
    statisticsCharts.orders = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Заказов',
                data: values,
                backgroundColor: '#FFB886',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

function renderStatusChart(data) {
    const ctx = document.getElementById('statusChart');
    if (!ctx) return;
    
    if (statisticsCharts.status) {
        statisticsCharts.status.destroy();
    }
    
    const statusLabels = {
        'pending': 'Ожидают',
        'processing': 'В обработке',
        'delivered': 'Доставлены',
        'cancelled': 'Отменены'
    };
    
    const labels = Object.keys(data).map(key => statusLabels[key] || key);
    const values = Object.values(data);
    const colors = ['#FFA726', '#42A5F5', '#66BB6A', '#EF5350'];
    
    statisticsCharts.status = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: colors.slice(0, values.length)
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    });
}

function renderTopProductsChart(data) {
    const ctx = document.getElementById('topProductsChart');
    if (!ctx) return;
    
    if (statisticsCharts.topProducts) {
        statisticsCharts.topProducts.destroy();
    }
    
    if (!data || data.length === 0) {
        ctx.getContext('2d').clearRect(0, 0, ctx.width, ctx.height);
        return;
    }
    
    // Берем первые 5 товаров
    const top5 = data.slice(0, 5);
    const labels = top5.map(item => {
        const name = item.product_name || 'Неизвестный товар';
        return name.length > 20 ? name.substring(0, 20) + '...' : name;
    });
    const values = top5.map(item => item.total_quantity);
    
    statisticsCharts.topProducts = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Количество продаж',
                data: values,
                backgroundColor: '#FF8C69',
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

// Инициализация обработчиков для дашборда
function initStatisticsDashboard() {
    // Кнопка загрузки статистики
    document.getElementById('loadStatisticsBtn')?.addEventListener('click', () => {
        loadShopStatistics();
    });
    
    // Быстрый выбор периода
    document.querySelectorAll('.period-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const period = btn.dataset.period;
            const endDate = new Date();
            const startDate = new Date();
            
            if (period === '7') {
                startDate.setDate(endDate.getDate() - 7);
            } else if (period === '30') {
                startDate.setDate(endDate.getDate() - 30);
            } else if (period === '90') {
                startDate.setDate(endDate.getDate() - 90);
            } else if (period === 'month') {
                startDate.setDate(1);
            }
            
            const startInput = document.getElementById('statisticsStartDate');
            const endInput = document.getElementById('statisticsEndDate');
            
            if (startInput) {
                startInput.value = startDate.toISOString().split('T')[0];
            }
            if (endInput) {
                endInput.value = endDate.toISOString().split('T')[0];
            }
            
            loadShopStatistics();
        });
    });
    
    // Инициализация дат по умолчанию (последние 30 дней)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - 30);
    
    const startInput = document.getElementById('statisticsStartDate');
    const endInput = document.getElementById('statisticsEndDate');
    
    if (startInput && !startInput.value) {
        startInput.value = startDate.toISOString().split('T')[0];
    }
    if (endInput && !endInput.value) {
        endInput.value = endDate.toISOString().split('T')[0];
    }
}

// ==================== End of Shop Statistics ====================

        console.log('✅ [APP] DOM already loaded, initializing immediately');
        try {
            init();
        } catch (error) {
            console.error('❌ Ошибка в init():', error);
            alert('Ошибка инициализации: ' + error.message);
        }
    }
} catch (error) {
    console.error('❌ Критическая ошибка при настройке инициализации:', error);
    alert('Критическая ошибка: ' + error.message);
}

// Проверка через 2 секунды
setTimeout(() => {
    console.log('🔍 Проверка инициализации...');
    if (typeof elements === 'undefined') {
        console.error('❌ ОШИБКА: elements не определён!');
    } else if (!elements.searchBtn) {
        console.error('❌ ОШИБКА: elements.searchBtn не найден!');
        console.log('Доступные элементы:', Object.keys(elements).slice(0, 10));
    } else {
        console.log('✅ Приложение инициализировано успешно!');
        console.log('✅ searchBtn найден:', elements.searchBtn);
    }
}, 2000);

// Глобальная проверка элементов после загрузки
setTimeout(() => {
    console.log('[APP] Element check after 1 second:');
    console.log('  searchBtn:', !!elements.searchBtn);
    console.log('  bottomNav:', !!elements.bottomNav);
    console.log('  cartBtn:', !!elements.cartBtn);
    console.log('  favoritesBtn:', !!elements.favoritesBtn);
}, 1000);

